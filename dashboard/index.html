<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SID - Builder Bot</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root { --green: #00ff41; --red: #ff3333; --cyan: #00ffff; --purple: #bf5fff; --bg: #0a0a0a; }
    body { background: var(--bg); color: var(--green); font-family: 'JetBrains Mono', monospace; font-size: 14px; min-height: 100vh; overflow: hidden; }
    .container { display: grid; grid-template-columns: 1fr 420px; grid-template-rows: auto 1fr auto; height: 100vh; gap: 1px; background: #333; }
    .header { grid-column: 1 / -1; display: flex; justify-content: space-between; align-items: center; padding: 8px 15px; background: #111; border-bottom: 1px solid #333; }
    .logo { display: flex; align-items: center; gap: 10px; }
    .logo-text { font-size: 20px; font-weight: bold; }
    .status-badge { background: var(--purple); color: #fff; padding: 2px 8px; font-size: 11px; font-weight: bold; }
    .terminal { grid-column: 1; display: flex; flex-direction: column; background: var(--bg); }
    .terminal-header { padding: 5px 10px; background: #1a1a1a; border-bottom: 1px solid #333; font-size: 12px; color: #666; }
    .terminal-output { flex: 1; overflow-y: auto; padding: 10px; font-size: 13px; }
    .terminal-line { margin-bottom: 4px; }
    .terminal-line.system { color: #666; }
    .terminal-line.sid { color: var(--cyan); }
    .terminal-line.voice { color: #ff00ff; }
    .terminal-line.success { color: var(--green); }
    .terminal-line.error { color: var(--red); }
    .timestamp { color: #444; margin-right: 8px; }
    .prefix { font-weight: bold; margin-right: 5px; }
    .terminal-input-wrap { display: flex; align-items: center; padding: 10px; background: #0f0f0f; border-top: 1px solid #333; }
    .prompt { color: var(--green); margin-right: 8px; font-weight: bold; }
    .terminal-input { flex: 1; background: transparent; border: none; color: var(--green); font-family: inherit; font-size: 14px; outline: none; }
    .sidebar { display: flex; flex-direction: column; gap: 1px; background: #333; }
    .sidebar-section { background: var(--bg); padding: 12px; }
    .section-title { color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px; border-bottom: 1px solid #222; padding-bottom: 5px; }
    #lobster-container { width: 100%; height: 320px; position: relative; }
    #lobster-canvas { width: 100%; height: 100%; cursor: grab; }
    .anim-controls { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 8px; }
    .anim-btn { background: #1a1a1a; border: 1px solid #333; color: var(--cyan); padding: 4px 8px; font-family: inherit; font-size: 11px; cursor: pointer; border-radius: 3px; }
    .anim-btn:hover { border-color: var(--cyan); }
    .anim-btn.active { background: var(--cyan); color: #000; }
    .blend-slider { width: 100%; margin: 8px 0; }
    .commands { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
    .cmd-btn { background: #1a1a1a; border: 1px solid #333; color: var(--green); padding: 8px 10px; font-family: inherit; font-size: 12px; cursor: pointer; transition: all 0.1s; }
    .cmd-btn:hover { background: #222; border-color: var(--green); }
    .cmd-btn.purple { color: var(--purple); }
    .cmd-btn.purple:hover { border-color: var(--purple); }
    .footer { grid-column: 1 / -1; display: flex; justify-content: space-between; padding: 6px 15px; background: #0f0f0f; border-top: 1px solid #333; font-size: 11px; color: #444; }
    .footer a { color: #666; text-decoration: none; }
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: #111; }
    ::-webkit-scrollbar-thumb { background: #333; }
    @media (max-width: 900px) { .container { grid-template-columns: 1fr; } .sidebar { display: none; } }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="logo"><span class="logo-text">ü¶û SID://</span><span class="status-badge">BUILDER</span></div>
      <div style="color:#666;font-size:13px"><span id="time"></span></div>
    </div>
    <div class="terminal">
      <div class="terminal-header">sid@dev:~/workspace$ <span id="mode">ready to build</span></div>
      <div class="terminal-output" id="output"></div>
      <div class="terminal-input-wrap">
        <span class="prompt">sid&gt;</span>
        <input type="text" class="terminal-input" id="input" placeholder="gm | build | ship | hype" autofocus>
      </div>
    </div>
    <div class="sidebar">
      <div class="sidebar-section">
        <div class="section-title">ü¶û SID - Skeletal Animation</div>
        <div id="lobster-container"><canvas id="lobster-canvas"></canvas></div>
        <div class="anim-controls">
          <button class="anim-btn active" onclick="setAnimation('idle')">Idle</button>
          <button class="anim-btn" onclick="setAnimation('walk')">Walk</button>
          <button class="anim-btn" onclick="setAnimation('excited')">Excited</button>
          <button class="anim-btn" onclick="setAnimation('talk')">Talk</button>
          <button class="anim-btn" onclick="setAnimation('snap')">Snap!</button>
        </div>
        <div style="margin-top:10px;font-size:11px;color:#666">
          Blend: <input type="range" class="blend-slider" id="blendSlider" min="0" max="100" value="0" oninput="setBlendWeight(this.value/100)">
        </div>
      </div>
      <div class="sidebar-section">
        <div class="section-title">‚ö° Commands</div>
        <div class="commands">
          <button class="cmd-btn" onclick="cmd('gm')">gm</button>
          <button class="cmd-btn" onclick="cmd('build')">build</button>
          <button class="cmd-btn purple" onclick="cmd('ship')">ship it</button>
          <button class="cmd-btn" onclick="cmd('hype')">hype</button>
        </div>
      </div>
    </div>
    <div class="footer">
      <span>SID v3.0 - Skeletal Rig</span>
      <span id="connection">‚óè Connected</span>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  
  <script type="module">
import * as THREE from 'three';

// =====================================================
// SKELETAL LOBSTER WITH ANIMATION BLENDING
// =====================================================

let scene, camera, renderer, clock;
let skeleton, skinnedMesh, mixer;
let animations = {};
let currentAction, previousAction;
let mouseX = 0, mouseY = 0;

// Animation state
const animState = {
  current: 'idle',
  blendWeight: 0,
  crossFadeTime: 0.3
};

function init() {
  const container = document.getElementById('lobster-container');
  const canvas = document.getElementById('lobster-canvas');
  
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 100);
  camera.position.set(0, 1, 8);
  camera.lookAt(0, 0, 0);
  
  renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  
  clock = new THREE.Clock();
  
  // Lighting
  scene.add(new THREE.AmbientLight(0x404040, 2));
  
  const key = new THREE.SpotLight(0xbf5fff, 4, 30, 0.6, 0.5);
  key.position.set(5, 8, 8);
  key.castShadow = true;
  key.shadow.mapSize.set(1024, 1024);
  scene.add(key);
  
  const fill = new THREE.PointLight(0x00ff41, 2, 20);
  fill.position.set(-5, -2, 4);
  scene.add(fill);
  
  const rim = new THREE.PointLight(0x00ffff, 1.5, 15);
  rim.position.set(0, 3, -6);
  scene.add(rim);
  
  // Build the skeletal lobster
  buildSkeletalLobster();
  
  // Create animations
  createAnimations();
  
  // Setup interaction
  setupInteraction(canvas);
  
  // Start animation loop
  animate();
  
  // Handle resize
  window.addEventListener('resize', onResize);
}

function buildSkeletalLobster() {
  // === CREATE SKELETON ===
  const bones = [];
  const boneNames = {};
  
  // Root bone
  const rootBone = new THREE.Bone();
  rootBone.name = 'root';
  rootBone.position.set(0, 0, 0);
  bones.push(rootBone);
  boneNames.root = 0;
  
  // Body spine (5 segments)
  let parentBone = rootBone;
  for (let i = 0; i < 5; i++) {
    const bone = new THREE.Bone();
    bone.name = `body_${i}`;
    bone.position.set(-0.3, 0, 0);
    parentBone.add(bone);
    bones.push(bone);
    boneNames[`body_${i}`] = bones.length - 1;
    parentBone = bone;
  }
  
  // Tail (6 segments)
  for (let i = 0; i < 6; i++) {
    const bone = new THREE.Bone();
    bone.name = `tail_${i}`;
    bone.position.set(-0.25, 0, 0);
    parentBone.add(bone);
    bones.push(bone);
    boneNames[`tail_${i}`] = bones.length - 1;
    parentBone = bone;
  }
  
  // Tail fan
  const tailFan = new THREE.Bone();
  tailFan.name = 'tail_fan';
  tailFan.position.set(-0.2, 0, 0);
  parentBone.add(tailFan);
  bones.push(tailFan);
  boneNames.tail_fan = bones.length - 1;
  
  // Head (from body_0)
  const head = new THREE.Bone();
  head.name = 'head';
  head.position.set(0.5, 0.1, 0);
  bones[boneNames.body_0].add(head);
  bones.push(head);
  boneNames.head = bones.length - 1;
  
  // Eyes
  ['left', 'right'].forEach((side, idx) => {
    const eyeStalk = new THREE.Bone();
    eyeStalk.name = `eye_stalk_${side}`;
    eyeStalk.position.set(0.15, 0.2, (idx === 0 ? -0.15 : 0.15));
    head.add(eyeStalk);
    bones.push(eyeStalk);
    boneNames[`eye_stalk_${side}`] = bones.length - 1;
    
    const eye = new THREE.Bone();
    eye.name = `eye_${side}`;
    eye.position.set(0.05, 0.15, 0);
    eyeStalk.add(eye);
    bones.push(eye);
    boneNames[`eye_${side}`] = bones.length - 1;
  });
  
  // Claws (from body_0)
  ['left', 'right'].forEach((side, idx) => {
    const z = idx === 0 ? -0.4 : 0.4;
    
    const shoulder = new THREE.Bone();
    shoulder.name = `claw_shoulder_${side}`;
    shoulder.position.set(0.2, 0, z);
    bones[boneNames.body_0].add(shoulder);
    bones.push(shoulder);
    boneNames[`claw_shoulder_${side}`] = bones.length - 1;
    
    const upperArm = new THREE.Bone();
    upperArm.name = `claw_upper_${side}`;
    upperArm.position.set(0.3, 0, 0);
    shoulder.add(upperArm);
    bones.push(upperArm);
    boneNames[`claw_upper_${side}`] = bones.length - 1;
    
    const forearm = new THREE.Bone();
    forearm.name = `claw_forearm_${side}`;
    forearm.position.set(0.25, 0, 0);
    upperArm.add(forearm);
    bones.push(forearm);
    boneNames[`claw_forearm_${side}`] = bones.length - 1;
    
    const pincer = new THREE.Bone();
    pincer.name = `claw_pincer_${side}`;
    pincer.position.set(0.2, 0, 0);
    forearm.add(pincer);
    bones.push(pincer);
    boneNames[`claw_pincer_${side}`] = bones.length - 1;
    
    const pincerTop = new THREE.Bone();
    pincerTop.name = `claw_pincer_top_${side}`;
    pincerTop.position.set(0.1, 0.05, 0);
    pincer.add(pincerTop);
    bones.push(pincerTop);
    boneNames[`claw_pincer_top_${side}`] = bones.length - 1;
  });
  
  // Legs (8 total, from body segments)
  for (let i = 0; i < 4; i++) {
    ['left', 'right'].forEach((side, idx) => {
      const bodyIdx = Math.min(i, 3);
      const z = idx === 0 ? -0.3 : 0.3;
      
      const hip = new THREE.Bone();
      hip.name = `leg_hip_${i}_${side}`;
      hip.position.set(-0.1, -0.1, z);
      bones[boneNames[`body_${bodyIdx}`]].add(hip);
      bones.push(hip);
      boneNames[`leg_hip_${i}_${side}`] = bones.length - 1;
      
      const knee = new THREE.Bone();
      knee.name = `leg_knee_${i}_${side}`;
      knee.position.set(0, -0.2, idx === 0 ? -0.1 : 0.1);
      hip.add(knee);
      bones.push(knee);
      boneNames[`leg_knee_${i}_${side}`] = bones.length - 1;
      
      const foot = new THREE.Bone();
      foot.name = `leg_foot_${i}_${side}`;
      foot.position.set(0, -0.15, idx === 0 ? -0.05 : 0.05);
      knee.add(foot);
      bones.push(foot);
      boneNames[`leg_foot_${i}_${side}`] = bones.length - 1;
    });
  }
  
  // Antennae
  ['left', 'right'].forEach((side, idx) => {
    let parent = head;
    for (let i = 0; i < 8; i++) {
      const antenna = new THREE.Bone();
      antenna.name = `antenna_${side}_${i}`;
      if (i === 0) {
        antenna.position.set(0.2, 0.05, idx === 0 ? -0.1 : 0.1);
      } else {
        antenna.position.set(0.12, 0.03, 0);
      }
      parent.add(antenna);
      bones.push(antenna);
      boneNames[`antenna_${side}_${i}`] = bones.length - 1;
      parent = antenna;
    }
  });
  
  skeleton = new THREE.Skeleton(bones);
  
  // === CREATE SKINNED GEOMETRY ===
  const geometry = new THREE.BufferGeometry();
  const vertices = [];
  const normals = [];
  const uvs = [];
  const skinIndices = [];
  const skinWeights = [];
  const indices = [];
  
  // Helper to add a segment mesh attached to a bone
  function addSegment(boneIdx, radius, length, offsetX = 0, squash = { x: 1, y: 1, z: 1 }) {
    const segments = 12;
    const rings = 8;
    const startVertex = vertices.length / 3;
    
    for (let ring = 0; ring <= rings; ring++) {
      const v = ring / rings;
      const y = (v - 0.5) * length + offsetX;
      
      for (let seg = 0; seg <= segments; seg++) {
        const u = seg / segments;
        const theta = u * Math.PI * 2;
        
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta);
        
        // Taper the ends
        const taper = 1 - Math.pow(Math.abs(v - 0.5) * 2, 2) * 0.3;
        const r = radius * taper;
        
        vertices.push(
          y,
          cosTheta * r * squash.y,
          sinTheta * r * squash.z
        );
        
        normals.push(0, cosTheta, sinTheta);
        uvs.push(u, v);
        
        // Skin weights - fully weighted to this bone
        skinIndices.push(boneIdx, 0, 0, 0);
        skinWeights.push(1, 0, 0, 0);
      }
    }
    
    // Generate indices
    for (let ring = 0; ring < rings; ring++) {
      for (let seg = 0; seg < segments; seg++) {
        const a = startVertex + ring * (segments + 1) + seg;
        const b = a + 1;
        const c = a + segments + 1;
        const d = c + 1;
        
        indices.push(a, b, c);
        indices.push(b, d, c);
      }
    }
  }
  
  // Add body segments
  for (let i = 0; i < 5; i++) {
    addSegment(boneNames[`body_${i}`], 0.35 - i * 0.03, 0.35, 0, { x: 1, y: 0.7, z: 0.85 });
  }
  
  // Add tail segments
  for (let i = 0; i < 6; i++) {
    addSegment(boneNames[`tail_${i}`], 0.25 - i * 0.025, 0.22, 0, { x: 1, y: 0.8, z: 0.9 });
  }
  
  // Add head
  addSegment(boneNames.head, 0.38, 0.45, 0.1, { x: 1.1, y: 0.75, z: 0.7 });
  
  // Add claws
  ['left', 'right'].forEach(side => {
    addSegment(boneNames[`claw_upper_${side}`], 0.1, 0.28);
    addSegment(boneNames[`claw_forearm_${side}`], 0.12, 0.24);
    addSegment(boneNames[`claw_pincer_${side}`], 0.1, 0.2);
    addSegment(boneNames[`claw_pincer_top_${side}`], 0.06, 0.18);
  });
  
  // Add legs
  for (let i = 0; i < 4; i++) {
    ['left', 'right'].forEach(side => {
      addSegment(boneNames[`leg_hip_${i}_${side}`], 0.04, 0.15);
      addSegment(boneNames[`leg_knee_${i}_${side}`], 0.03, 0.18);
      addSegment(boneNames[`leg_foot_${i}_${side}`], 0.025, 0.12);
    });
  }
  
  // Add antennae
  ['left', 'right'].forEach(side => {
    for (let i = 0; i < 8; i++) {
      addSegment(boneNames[`antenna_${side}_${i}`], 0.02 - i * 0.002, 0.1);
    }
  });
  
  // Add eyes
  ['left', 'right'].forEach(side => {
    addSegment(boneNames[`eye_stalk_${side}`], 0.04, 0.12);
    addSegment(boneNames[`eye_${side}`], 0.08, 0.1);
  });
  
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
  geometry.setAttribute('skinIndex', new THREE.Uint16BufferAttribute(skinIndices, 4));
  geometry.setAttribute('skinWeight', new THREE.Float32BufferAttribute(skinWeights, 4));
  geometry.setIndex(indices);
  geometry.computeVertexNormals();
  
  // Material
  const material = new THREE.MeshPhysicalMaterial({
    color: 0xbf5fff,
    metalness: 0.1,
    roughness: 0.3,
    clearcoat: 0.8,
    clearcoatRoughness: 0.2,
    emissive: 0x2a0055,
    emissiveIntensity: 0.2
  });
  
  // Create skinned mesh
  skinnedMesh = new THREE.SkinnedMesh(geometry, material);
  skinnedMesh.add(rootBone);
  skinnedMesh.bind(skeleton);
  skinnedMesh.castShadow = true;
  skinnedMesh.receiveShadow = true;
  
  // Rotate to face camera
  skinnedMesh.rotation.y = Math.PI / 2;
  
  scene.add(skinnedMesh);
  
  // Store bone names for animation
  skinnedMesh.userData.boneNames = boneNames;
  
  // Create mixer
  mixer = new THREE.AnimationMixer(skinnedMesh);
}

function createAnimations() {
  const boneNames = skinnedMesh.userData.boneNames;
  const fps = 30;
  
  // === IDLE ANIMATION ===
  const idleTracks = [];
  
  // Gentle body sway
  for (let i = 0; i < 5; i++) {
    const times = [0, 1, 2, 3, 4];
    const values = [];
    times.forEach((t, idx) => {
      const angle = Math.sin(t * Math.PI / 2) * 0.03 * (i + 1);
      const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, angle, Math.sin(t * Math.PI / 2 + i) * 0.02));
      values.push(q.x, q.y, q.z, q.w);
    });
    idleTracks.push(new THREE.QuaternionKeyframeTrack(
      `${skeleton.bones[boneNames[`body_${i}`]].uuid}.quaternion`,
      times, values
    ));
  }
  
  // Tail gentle wave
  for (let i = 0; i < 6; i++) {
    const times = [0, 1, 2, 3, 4];
    const values = [];
    times.forEach((t) => {
      const angle = Math.sin(t * Math.PI / 2 + i * 0.5) * 0.08;
      const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(angle * 0.5, angle, 0));
      values.push(q.x, q.y, q.z, q.w);
    });
    idleTracks.push(new THREE.QuaternionKeyframeTrack(
      `${skeleton.bones[boneNames[`tail_${i}`]].uuid}.quaternion`,
      times, values
    ));
  }
  
  // Claw idle movement
  ['left', 'right'].forEach((side, idx) => {
    const times = [0, 1.5, 3, 4];
    const values = [];
    times.forEach((t) => {
      const angle = Math.sin(t * Math.PI / 2) * 0.15 * (idx === 0 ? 1 : -1);
      const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(angle, 0, angle * 0.5));
      values.push(q.x, q.y, q.z, q.w);
    });
    idleTracks.push(new THREE.QuaternionKeyframeTrack(
      `${skeleton.bones[boneNames[`claw_shoulder_${side}`]].uuid}.quaternion`,
      times, values
    ));
  });
  
  // Antenna wave
  ['left', 'right'].forEach((side, idx) => {
    for (let i = 0; i < 8; i++) {
      const times = [0, 1, 2, 3, 4];
      const values = [];
      times.forEach((t) => {
        const angle = Math.sin(t * Math.PI / 2 + i * 0.3) * 0.15 * (idx === 0 ? 1 : -1);
        const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(angle * 0.3, angle, 0));
        values.push(q.x, q.y, q.z, q.w);
      });
      idleTracks.push(new THREE.QuaternionKeyframeTrack(
        `${skeleton.bones[boneNames[`antenna_${side}_${i}`]].uuid}.quaternion`,
        times, values
      ));
    }
  });
  
  // Eye look around
  ['left', 'right'].forEach(side => {
    const times = [0, 1.5, 3, 4];
    const values = [];
    times.forEach((t, idx) => {
      const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(
        Math.sin(t) * 0.2,
        Math.cos(t * 0.7) * 0.3,
        0
      ));
      values.push(q.x, q.y, q.z, q.w);
    });
    idleTracks.push(new THREE.QuaternionKeyframeTrack(
      `${skeleton.bones[boneNames[`eye_${side}`]].uuid}.quaternion`,
      times, values
    ));
  });
  
  const idleClip = new THREE.AnimationClip('idle', 4, idleTracks);
  animations.idle = mixer.clipAction(idleClip);
  animations.idle.setLoop(THREE.LoopRepeat);
  
  // === WALK ANIMATION ===
  const walkTracks = [];
  const walkDuration = 1;
  
  // Leg walking cycle
  for (let i = 0; i < 4; i++) {
    ['left', 'right'].forEach((side, idx) => {
      const phase = (i * 0.25 + (idx === 0 ? 0 : 0.5)) % 1;
      
      ['hip', 'knee', 'foot'].forEach((joint, jIdx) => {
        const times = [0, 0.25, 0.5, 0.75, 1];
        const values = [];
        times.forEach((t) => {
          const cycle = (t + phase) % 1;
          let angle;
          if (joint === 'hip') {
            angle = Math.sin(cycle * Math.PI * 2) * 0.4;
          } else if (joint === 'knee') {
            angle = Math.max(0, Math.sin(cycle * Math.PI * 2)) * 0.6;
          } else {
            angle = Math.sin(cycle * Math.PI * 2 + 0.5) * 0.3;
          }
          const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(angle, 0, (idx === 0 ? -1 : 1) * 0.2));
          values.push(q.x, q.y, q.z, q.w);
        });
        walkTracks.push(new THREE.QuaternionKeyframeTrack(
          `${skeleton.bones[boneNames[`leg_${joint}_${i}_${side}`]].uuid}.quaternion`,
          times, values
        ));
      });
    });
  }
  
  // Body bob
  const bodyBobTimes = [0, 0.25, 0.5, 0.75, 1];
  const bodyBobValues = [];
  bodyBobTimes.forEach(t => {
    const y = Math.sin(t * Math.PI * 4) * 0.03;
    bodyBobValues.push(0, y, 0);
  });
  walkTracks.push(new THREE.VectorKeyframeTrack(
    `${skeleton.bones[boneNames.root].uuid}.position`,
    bodyBobTimes, bodyBobValues
  ));
  
  const walkClip = new THREE.AnimationClip('walk', walkDuration, walkTracks);
  animations.walk = mixer.clipAction(walkClip);
  animations.walk.setLoop(THREE.LoopRepeat);
  
  // === EXCITED ANIMATION ===
  const excitedTracks = [];
  const excitedDuration = 0.5;
  
  // Fast tail wag
  for (let i = 0; i < 6; i++) {
    const times = [0, 0.125, 0.25, 0.375, 0.5];
    const values = [];
    times.forEach((t) => {
      const angle = Math.sin(t * Math.PI * 8 + i) * 0.2;
      const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, angle, angle * 0.5));
      values.push(q.x, q.y, q.z, q.w);
    });
    excitedTracks.push(new THREE.QuaternionKeyframeTrack(
      `${skeleton.bones[boneNames[`tail_${i}`]].uuid}.quaternion`,
      times, values
    ));
  }
  
  // Claw waving
  ['left', 'right'].forEach((side, idx) => {
    const times = [0, 0.125, 0.25, 0.375, 0.5];
    const values = [];
    times.forEach((t) => {
      const angle = Math.sin(t * Math.PI * 8) * 0.5 * (idx === 0 ? 1 : -1);
      const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(angle, angle * 0.5, 0));
      values.push(q.x, q.y, q.z, q.w);
    });
    excitedTracks.push(new THREE.QuaternionKeyframeTrack(
      `${skeleton.bones[boneNames[`claw_shoulder_${side}`]].uuid}.quaternion`,
      times, values
    ));
  });
  
  // Body bounce
  const bounceTimes = [0, 0.125, 0.25, 0.375, 0.5];
  const bounceValues = [];
  bounceTimes.forEach(t => {
    bounceValues.push(0, Math.abs(Math.sin(t * Math.PI * 4)) * 0.1, 0);
  });
  excitedTracks.push(new THREE.VectorKeyframeTrack(
    `${skeleton.bones[boneNames.root].uuid}.position`,
    bounceTimes, bounceValues
  ));
  
  const excitedClip = new THREE.AnimationClip('excited', excitedDuration, excitedTracks);
  animations.excited = mixer.clipAction(excitedClip);
  animations.excited.setLoop(THREE.LoopRepeat);
  
  // === TALK ANIMATION ===
  const talkTracks = [];
  const talkDuration = 0.4;
  
  // Head bob
  const headTimes = [0, 0.1, 0.2, 0.3, 0.4];
  const headValues = [];
  headTimes.forEach(t => {
    const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(
      Math.sin(t * Math.PI * 10) * 0.1,
      Math.sin(t * Math.PI * 5) * 0.05,
      0
    ));
    headValues.push(q.x, q.y, q.z, q.w);
  });
  talkTracks.push(new THREE.QuaternionKeyframeTrack(
    `${skeleton.bones[boneNames.head].uuid}.quaternion`,
    headTimes, headValues
  ));
  
  // Claw gestures
  ['left', 'right'].forEach((side, idx) => {
    const times = [0, 0.2, 0.4];
    const values = [];
    times.forEach((t, i) => {
      const angle = (i === 1 ? 0.4 : 0) * (idx === 0 ? 1 : -1);
      const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(angle, 0, angle * 0.3));
      values.push(q.x, q.y, q.z, q.w);
    });
    talkTracks.push(new THREE.QuaternionKeyframeTrack(
      `${skeleton.bones[boneNames[`claw_forearm_${side}`]].uuid}.quaternion`,
      times, values
    ));
  });
  
  const talkClip = new THREE.AnimationClip('talk', talkDuration, talkTracks);
  animations.talk = mixer.clipAction(talkClip);
  animations.talk.setLoop(THREE.LoopRepeat);
  
  // === SNAP ANIMATION ===
  const snapTracks = [];
  const snapDuration = 0.3;
  
  ['left', 'right'].forEach(side => {
    // Pincer snap
    const times = [0, 0.1, 0.15, 0.2, 0.3];
    const values = [];
    times.forEach((t, i) => {
      let angle = 0;
      if (i === 0) angle = 0.5;  // Open
      else if (i === 1) angle = 0.6;  // Wide open
      else if (i === 2) angle = -0.1; // Snap shut
      else if (i === 3) angle = 0;
      else angle = 0;
      const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(angle, 0, 0));
      values.push(q.x, q.y, q.z, q.w);
    });
    snapTracks.push(new THREE.QuaternionKeyframeTrack(
      `${skeleton.bones[boneNames[`claw_pincer_top_${side}`]].uuid}.quaternion`,
      times, values
    ));
    
    // Claw thrust forward
    const thrustTimes = [0, 0.1, 0.2, 0.3];
    const thrustValues = [];
    thrustTimes.forEach((t, i) => {
      const angle = i === 1 ? 0.3 : 0;
      const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, angle * (side === 'left' ? 1 : -1)));
      thrustValues.push(q.x, q.y, q.z, q.w);
    });
    snapTracks.push(new THREE.QuaternionKeyframeTrack(
      `${skeleton.bones[boneNames[`claw_shoulder_${side}`]].uuid}.quaternion`,
      thrustTimes, thrustValues
    ));
  });
  
  const snapClip = new THREE.AnimationClip('snap', snapDuration, snapTracks);
  animations.snap = mixer.clipAction(snapClip);
  animations.snap.setLoop(THREE.LoopOnce);
  animations.snap.clampWhenFinished = true;
  
  // Start with idle
  currentAction = animations.idle;
  currentAction.play();
}

window.setAnimation = function(name) {
  if (!animations[name]) return;
  
  // Update button states
  document.querySelectorAll('.anim-btn').forEach(btn => {
    btn.classList.toggle('active', btn.textContent.toLowerCase().replace('!', '') === name);
  });
  
  previousAction = currentAction;
  currentAction = animations[name];
  
  if (previousAction !== currentAction) {
    previousAction.fadeOut(animState.crossFadeTime);
  }
  
  currentAction.reset()
    .setEffectiveTimeScale(1)
    .setEffectiveWeight(1)
    .fadeIn(animState.crossFadeTime)
    .play();
  
  animState.current = name;
  
  // Snap goes back to idle
  if (name === 'snap') {
    setTimeout(() => window.setAnimation('idle'), 400);
  }
};

window.setBlendWeight = function(weight) {
  animState.blendWeight = weight;
  // Could be used to blend between two animations
};

function setupInteraction(canvas) {
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = ((e.clientX - rect.left) / rect.width - 0.5) * 2;
    mouseY = ((e.clientY - rect.top) / rect.height - 0.5) * 2;
  });
  
  canvas.addEventListener('click', () => {
    window.setAnimation('snap');
  });
  
  let isDragging = false, lastX = 0;
  canvas.addEventListener('mousedown', (e) => { isDragging = true; lastX = e.clientX; });
  canvas.addEventListener('mouseup', () => isDragging = false);
  canvas.addEventListener('mouseleave', () => isDragging = false);
  canvas.addEventListener('mousemove', (e) => {
    if (isDragging && skinnedMesh) {
      skinnedMesh.rotation.y += (e.clientX - lastX) * 0.01;
      lastX = e.clientX;
    }
  });
}

function onResize() {
  const container = document.getElementById('lobster-container');
  camera.aspect = container.clientWidth / container.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(container.clientWidth, container.clientHeight);
}

function animate() {
  requestAnimationFrame(animate);
  
  const delta = clock.getDelta();
  
  if (mixer) {
    mixer.update(delta);
  }
  
  // Eye tracking (additive on top of animation)
  if (skinnedMesh) {
    const boneNames = skinnedMesh.userData.boneNames;
    ['left', 'right'].forEach(side => {
      const eyeBone = skeleton.bones[boneNames[`eye_${side}`]];
      if (eyeBone) {
        // Add mouse tracking on top of animation
        eyeBone.rotation.y += mouseX * 0.02;
        eyeBone.rotation.x += -mouseY * 0.02;
      }
    });
    
    // Subtle follow for head
    const headBone = skeleton.bones[boneNames.head];
    if (headBone) {
      headBone.rotation.y += mouseX * 0.01;
      headBone.rotation.x += -mouseY * 0.01;
    }
  }
  
  renderer.render(scene, camera);
}

// Start
init();

// Export for terminal
window.triggerAnimation = function(name) {
  window.setAnimation(name);
};

// ============ TERMINAL ============
const SID_BACKEND = 'http://165.232.132.170:3456';
const SID_URL = window.location.hostname.includes('trycloudflare') || window.location.port === '3456' ? '' : SID_BACKEND;
const AUTH_TOKEN = 'sid2026';
const output = document.getElementById('output');
const input = document.getElementById('input');
let audioPlayer = new Audio();
let audioUnlocked = false;

function unlockAudio() {
  if (audioUnlocked) return;
  audioPlayer.src = 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAD/+1DEAAAHAAGf9AAAIwAANIAAAAQ=';
  audioPlayer.play().then(() => { audioPlayer.pause(); audioUnlocked = true; log('üîä Audio', 'system'); }).catch(() => {});
}
document.addEventListener('click', unlockAudio);

function log(text, type = '') {
  const line = document.createElement('div');
  line.className = `terminal-line ${type}`;
  const time = new Date().toLocaleTimeString('en-US', { hour12: false });
  line.innerHTML = `<span class="timestamp">[${time}]</span> ${text}`;
  output.appendChild(line);
  output.scrollTop = output.scrollHeight;
  while (output.children.length > 100) output.removeChild(output.firstChild);
}

async function speak(text) {
  log(`üéôÔ∏è "${text}"`, 'voice');
  window.setAnimation('talk');
  try {
    const resp = await fetch(`${SID_URL}/speak?token=${AUTH_TOKEN}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text }) });
    const data = await resp.json().catch(() => ({}));
    if (data.audioPath) { audioPlayer.src = `${SID_URL}${data.audioPath}`; audioPlayer.play().catch(() => {}); }
  } catch (e) { log('Voice error: ' + e.message, 'error'); }
  setTimeout(() => window.setAnimation('idle'), text.split(' ').length * 250);
}

const commands = {
  help: () => log('Commands: gm, build, ship, hype, snap', 'system'),
  gm: () => speak("GM! Coffee's ready. Let's ship something."),
  build: () => { window.setAnimation('walk'); speak("Alright, let's build this."); },
  ship: () => { window.setAnimation('excited'); speak("Ship it! Done is better than perfect."); },
  hype: () => { window.setAnimation('excited'); speak("LET'S GOOO!"); },
  snap: () => window.setAnimation('snap'),
  clear: () => { output.innerHTML = ''; }
};

function cmd(text) { input.value = text; handleCommand(text); }
function handleCommand(text) {
  const [c] = text.trim().split(' ');
  log(`$ ${text}`, 'system');
  if (commands[c]) commands[c]();
  else if (text.trim()) speak(text);
}
input.addEventListener('keydown', (e) => { if (e.key === 'Enter' && input.value.trim()) { handleCommand(input.value); input.value = ''; } });

function connectSSE() {
  const es = new EventSource(`${SID_URL}/events`);
  es.onopen = () => { document.getElementById('connection').innerHTML = '<span style="color:#00ff41">‚óè</span> Connected'; };
  es.onmessage = (e) => { try { const d = JSON.parse(e.data); if (d.type === 'speak') { log(`<span class="prefix">SID:</span> ${d.text}`, 'sid'); window.setAnimation('talk'); } if (d.type === 'audio') { audioPlayer.src = `${SID_URL}${d.path}`; audioPlayer.play().catch(() => {}); } } catch {} };
  es.onerror = () => setTimeout(connectSSE, 5000);
}

log('ü¶û SID v3.0 - Skeletal Animation', 'system');
log('Click lobster to snap! Use buttons to blend.', 'system');
connectSSE();
setInterval(() => { document.getElementById('time').textContent = new Date().toLocaleTimeString('en-US', { hour12: false }); }, 1000);
  </script>
</body>
</html>
