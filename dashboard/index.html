<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SID - Builder Bot</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root { --green: #00ff41; --red: #ff3333; --cyan: #00ffff; --purple: #bf5fff; --bg: #0a0a0a; }
    body { background: var(--bg); color: var(--green); font-family: 'JetBrains Mono', monospace; font-size: 14px; min-height: 100vh; overflow: hidden; }
    .container { display: grid; grid-template-columns: 1fr 400px; grid-template-rows: auto 1fr auto; height: 100vh; gap: 1px; background: #333; }
    .header { grid-column: 1 / -1; display: flex; justify-content: space-between; align-items: center; padding: 8px 15px; background: #111; border-bottom: 1px solid #333; }
    .logo { display: flex; align-items: center; gap: 10px; }
    .logo-text { font-size: 20px; font-weight: bold; }
    .status-badge { background: var(--purple); color: #fff; padding: 2px 8px; font-size: 11px; font-weight: bold; }
    .terminal { grid-column: 1; display: flex; flex-direction: column; background: var(--bg); }
    .terminal-header { padding: 5px 10px; background: #1a1a1a; border-bottom: 1px solid #333; font-size: 12px; color: #666; }
    .terminal-output { flex: 1; overflow-y: auto; padding: 10px; font-size: 13px; }
    .terminal-line { margin-bottom: 4px; }
    .terminal-line.system { color: #666; }
    .terminal-line.sid { color: var(--cyan); }
    .terminal-line.voice { color: #ff00ff; }
    .terminal-line.success { color: var(--green); }
    .terminal-line.error { color: var(--red); }
    .timestamp { color: #444; margin-right: 8px; }
    .prefix { font-weight: bold; margin-right: 5px; }
    .terminal-input-wrap { display: flex; align-items: center; padding: 10px; background: #0f0f0f; border-top: 1px solid #333; }
    .prompt { color: var(--green); margin-right: 8px; font-weight: bold; }
    .terminal-input { flex: 1; background: transparent; border: none; color: var(--green); font-family: inherit; font-size: 14px; outline: none; }
    .sidebar { display: flex; flex-direction: column; gap: 1px; background: #333; }
    .sidebar-section { background: var(--bg); padding: 12px; }
    .section-title { color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px; border-bottom: 1px solid #222; padding-bottom: 5px; }
    #lobster-container { width: 100%; height: 280px; }
    #lobster-canvas { width: 100%; height: 100%; cursor: grab; }
    .mood-indicator { text-align: center; font-size: 12px; color: #666; margin-top: 5px; }
    .mood-indicator .mood { color: var(--purple); }
    .commands { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
    .cmd-btn { background: #1a1a1a; border: 1px solid #333; color: var(--green); padding: 8px 10px; font-family: inherit; font-size: 12px; cursor: pointer; transition: all 0.1s; }
    .cmd-btn:hover { background: #222; border-color: var(--green); }
    .cmd-btn.purple { color: var(--purple); }
    .cmd-btn.purple:hover { border-color: var(--purple); }
    .footer { grid-column: 1 / -1; display: flex; justify-content: space-between; padding: 6px 15px; background: #0f0f0f; border-top: 1px solid #333; font-size: 11px; color: #444; }
    .footer a { color: #666; text-decoration: none; }
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: #111; }
    ::-webkit-scrollbar-thumb { background: #333; }
    @media (max-width: 900px) { .container { grid-template-columns: 1fr; } .sidebar { display: none; } }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="logo"><span class="logo-text">ü¶û SID://</span><span class="status-badge">BUILDER</span></div>
      <div style="color:#666;font-size:13px"><span id="time"></span></div>
    </div>
    <div class="terminal">
      <div class="terminal-header">sid@dev:~/workspace$ <span id="mode">ready to build</span></div>
      <div class="terminal-output" id="output"></div>
      <div class="terminal-input-wrap">
        <span class="prompt">sid&gt;</span>
        <input type="text" class="terminal-input" id="input" placeholder="gm | build | ship | hype" autofocus>
      </div>
    </div>
    <div class="sidebar">
      <div class="sidebar-section">
        <div class="section-title">ü¶û SID</div>
        <div id="lobster-container"><canvas id="lobster-canvas"></canvas></div>
        <div class="mood-indicator">Mood: <span class="mood" id="mood">Chill</span></div>
      </div>
      <div class="sidebar-section">
        <div class="section-title">‚ö° Commands</div>
        <div class="commands">
          <button class="cmd-btn" onclick="cmd('gm')">gm</button>
          <button class="cmd-btn" onclick="cmd('build')">build</button>
          <button class="cmd-btn purple" onclick="cmd('ship')">ship it</button>
          <button class="cmd-btn" onclick="cmd('hype')">hype</button>
        </div>
      </div>
    </div>
    <div class="footer">
      <span>SID v2.0</span>
      <span id="connection">‚óè Connected</span>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
// =====================================================
// PROCEDURAL ANIMATED LOBSTER - Physics-based movement
// =====================================================

let scene, camera, renderer;
let lobsterGroup, bodyParts = {};
let mouseX = 0, mouseY = 0, targetRotY = 0;
let clock, mood = 'chill';

// Inverse Kinematics Chain for legs/antennae
class IKChain {
  constructor(segments, segmentLength, basePos, constraints = {}) {
    this.segments = [];
    this.segmentLength = segmentLength;
    this.basePos = basePos.clone();
    this.target = basePos.clone();
    this.constraints = { minAngle: -0.8, maxAngle: 0.8, ...constraints };
    
    let pos = basePos.clone();
    for (let i = 0; i < segments; i++) {
      this.segments.push({
        pos: pos.clone(),
        angle: 0,
        velocity: 0
      });
      pos.y -= segmentLength;
    }
  }
  
  solve(target, deltaTime) {
    this.target.lerp(target, 0.1);
    
    // FABRIK-like solving
    // Forward pass
    this.segments[this.segments.length - 1].pos.copy(this.target);
    for (let i = this.segments.length - 2; i >= 0; i--) {
      const dir = this.segments[i].pos.clone().sub(this.segments[i + 1].pos).normalize();
      this.segments[i].pos.copy(this.segments[i + 1].pos).add(dir.multiplyScalar(this.segmentLength));
    }
    
    // Backward pass
    this.segments[0].pos.copy(this.basePos);
    for (let i = 1; i < this.segments.length; i++) {
      const dir = this.segments[i].pos.clone().sub(this.segments[i - 1].pos).normalize();
      this.segments[i].pos.copy(this.segments[i - 1].pos).add(dir.multiplyScalar(this.segmentLength));
      
      // Add spring physics
      const springForce = (Math.random() - 0.5) * 0.01;
      this.segments[i].velocity += springForce;
      this.segments[i].velocity *= 0.95; // damping
      this.segments[i].pos.x += this.segments[i].velocity;
    }
  }
  
  getPositions() {
    return this.segments.map(s => s.pos.clone());
  }
}

// Soft body physics for body segments
class SoftBody {
  constructor(restPos, stiffness = 0.3, damping = 0.8) {
    this.restPos = restPos.clone();
    this.pos = restPos.clone();
    this.velocity = new THREE.Vector3();
    this.stiffness = stiffness;
    this.damping = damping;
  }
  
  update(parentPos, deltaTime) {
    // Spring force towards rest position relative to parent
    const targetPos = parentPos.clone().add(this.restPos);
    const force = targetPos.clone().sub(this.pos).multiplyScalar(this.stiffness);
    this.velocity.add(force);
    this.velocity.multiplyScalar(this.damping);
    this.pos.add(this.velocity.clone().multiplyScalar(deltaTime * 60));
  }
}

function initLobster() {
  const container = document.getElementById('lobster-container');
  const canvas = document.getElementById('lobster-canvas');
  
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
  camera.position.set(0, 0.5, 6);
  
  renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  
  clock = new THREE.Clock();
  
  // Lighting
  const ambient = new THREE.AmbientLight(0x404040, 1.5);
  scene.add(ambient);
  
  const key = new THREE.SpotLight(0xbf5fff, 3, 20, 0.5, 0.5);
  key.position.set(3, 4, 5);
  key.castShadow = true;
  scene.add(key);
  
  const fill = new THREE.PointLight(0x00ff41, 1.5, 15);
  fill.position.set(-4, -2, 3);
  scene.add(fill);
  
  const rim = new THREE.PointLight(0x00ffff, 1, 10);
  rim.position.set(0, 2, -4);
  scene.add(rim);
  
  buildProceduralLobster();
  setupInteraction(canvas);
  animate();
}

function buildProceduralLobster() {
  lobsterGroup = new THREE.Group();
  
  // Materials with subsurface scattering look
  const shellMat = new THREE.MeshPhysicalMaterial({
    color: 0xbf5fff,
    metalness: 0.1,
    roughness: 0.3,
    clearcoat: 0.8,
    clearcoatRoughness: 0.2,
    emissive: 0x1a0033,
    emissiveIntensity: 0.15
  });
  
  const clawMat = new THREE.MeshPhysicalMaterial({
    color: 0x9f3fff,
    metalness: 0.15,
    roughness: 0.25,
    clearcoat: 1,
    clearcoatRoughness: 0.1
  });
  
  const eyeMat = new THREE.MeshBasicMaterial({ color: 0x00ff41 });
  const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
  
  // === BODY (segmented with soft body physics) ===
  bodyParts.bodySegments = [];
  bodyParts.bodySoftBodies = [];
  
  for (let i = 0; i < 5; i++) {
    const size = 0.4 - i * 0.03;
    const geo = new THREE.SphereGeometry(size, 24, 18);
    // Squash into lobster shape
    geo.scale(1.3, 0.75, 0.85);
    
    const mesh = new THREE.Mesh(geo, shellMat.clone());
    mesh.position.x = -i * 0.28;
    mesh.castShadow = true;
    lobsterGroup.add(mesh);
    bodyParts.bodySegments.push(mesh);
    
    if (i > 0) {
      bodyParts.bodySoftBodies.push(new SoftBody(new THREE.Vector3(-0.28, 0, 0), 0.4, 0.85));
    }
  }
  
  // === HEAD ===
  const headGeo = new THREE.SphereGeometry(0.45, 24, 20);
  headGeo.scale(1.2, 0.8, 0.7);
  const head = new THREE.Mesh(headGeo, shellMat);
  head.position.set(0.55, 0.05, 0);
  head.castShadow = true;
  lobsterGroup.add(head);
  bodyParts.head = head;
  
  // Rostrum (pointy nose)
  const rostrumGeo = new THREE.ConeGeometry(0.12, 0.5, 8);
  const rostrum = new THREE.Mesh(rostrumGeo, shellMat);
  rostrum.rotation.z = -Math.PI / 2;
  rostrum.position.set(1.0, 0.1, 0);
  lobsterGroup.add(rostrum);
  
  // === EYES (on stalks, will track mouse) ===
  bodyParts.eyes = [];
  bodyParts.eyeStalks = [];
  
  [-1, 1].forEach((side, idx) => {
    // Eye stalk
    const stalkGeo = new THREE.CapsuleGeometry(0.04, 0.2, 8, 8);
    const stalk = new THREE.Mesh(stalkGeo, shellMat);
    stalk.position.set(0.7, 0.25, side * 0.18);
    lobsterGroup.add(stalk);
    bodyParts.eyeStalks.push(stalk);
    
    // Eye ball
    const eyeGroup = new THREE.Group();
    const eyeBall = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16), eyeMat);
    const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.055, 12, 12), pupilMat);
    pupil.position.z = 0.06;
    const eyelid = new THREE.Mesh(
      new THREE.SphereGeometry(0.105, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2),
      shellMat
    );
    eyelid.rotation.x = Math.PI;
    eyelid.visible = false;
    
    eyeGroup.add(eyeBall, pupil, eyelid);
    eyeGroup.position.set(0.75, 0.42, side * 0.22);
    eyeGroup.userData = { pupil, eyelid, baseY: 0.42 };
    lobsterGroup.add(eyeGroup);
    bodyParts.eyes.push(eyeGroup);
  });
  
  // === CLAWS (with pincer animation) ===
  bodyParts.claws = [];
  
  [-1, 1].forEach((side, idx) => {
    const clawGroup = new THREE.Group();
    
    // Arm segments
    const upperArm = new THREE.Mesh(new THREE.CapsuleGeometry(0.09, 0.35, 8, 12), clawMat);
    upperArm.rotation.z = Math.PI / 2 + side * 0.5;
    upperArm.position.set(0.18, 0, 0);
    clawGroup.add(upperArm);
    
    const forearm = new THREE.Mesh(new THREE.CapsuleGeometry(0.11, 0.3, 8, 12), clawMat);
    forearm.position.set(0.5, side * 0.08, 0);
    forearm.rotation.z = side * 0.4;
    clawGroup.add(forearm);
    
    // Pincer group (animated open/close)
    const pincerGroup = new THREE.Group();
    pincerGroup.position.set(0.7, side * 0.05, 0);
    
    // Main claw (bottom)
    const mainClawGeo = new THREE.BoxGeometry(0.35, 0.12, 0.1);
    mainClawGeo.translate(0.15, 0, 0);
    const mainClaw = new THREE.Mesh(mainClawGeo, clawMat);
    mainClaw.position.y = -0.04;
    pincerGroup.add(mainClaw);
    
    // Moving claw (top)
    const topClawGeo = new THREE.BoxGeometry(0.3, 0.08, 0.08);
    topClawGeo.translate(0.12, 0, 0);
    const topClaw = new THREE.Mesh(topClawGeo, clawMat);
    topClaw.position.set(0, 0.06, 0);
    topClaw.userData.restRotation = 0;
    pincerGroup.add(topClaw);
    pincerGroup.userData = { topClaw, isSnapping: false, snapPhase: 0 };
    
    clawGroup.add(pincerGroup);
    clawGroup.position.set(0.35, 0, side * 0.5);
    clawGroup.rotation.y = side * 0.7;
    clawGroup.userData = { side, pincerGroup, baseRotX: 0, baseRotZ: 0 };
    
    lobsterGroup.add(clawGroup);
    bodyParts.claws.push(clawGroup);
  });
  
  // === TAIL (with IK physics) ===
  bodyParts.tailSegments = [];
  bodyParts.tailChain = new IKChain(6, 0.22, new THREE.Vector3(-1.1, 0, 0));
  
  for (let i = 0; i < 6; i++) {
    const size = 0.28 - i * 0.03;
    const geo = new THREE.CylinderGeometry(size * 0.85, size, 0.18, 12);
    const seg = new THREE.Mesh(geo, shellMat);
    seg.rotation.z = Math.PI / 2;
    seg.castShadow = true;
    lobsterGroup.add(seg);
    bodyParts.tailSegments.push(seg);
  }
  
  // Tail fan
  const fanGroup = new THREE.Group();
  [-1, 0, 1].forEach(angle => {
    const fanGeo = new THREE.CircleGeometry(0.22, 12, 0, Math.PI * 0.85);
    const fan = new THREE.Mesh(fanGeo, shellMat);
    fan.rotation.y = Math.PI / 2;
    fan.rotation.z = angle * 0.5;
    fan.position.x = 0.05;
    fanGroup.add(fan);
  });
  fanGroup.position.x = -2.3;
  lobsterGroup.add(fanGroup);
  bodyParts.tailFan = fanGroup;
  
  // === LEGS (8 legs with IK) ===
  bodyParts.legs = [];
  bodyParts.legChains = [];
  
  for (let i = 0; i < 4; i++) {
    [-1, 1].forEach(side => {
      const legGroup = new THREE.Group();
      const basePos = new THREE.Vector3(-0.1 + i * 0.25, -0.15, side * 0.35);
      
      // Create leg segments
      for (let j = 0; j < 3; j++) {
        const thickness = 0.025 - j * 0.005;
        const length = 0.2 - j * 0.03;
        const seg = new THREE.Mesh(
          new THREE.CapsuleGeometry(thickness, length, 4, 6),
          shellMat
        );
        seg.castShadow = true;
        legGroup.add(seg);
      }
      
      legGroup.position.copy(basePos);
      lobsterGroup.add(legGroup);
      bodyParts.legs.push(legGroup);
      
      // IK chain for this leg
      const chain = new IKChain(3, 0.15, basePos);
      bodyParts.legChains.push({ chain, group: legGroup, side, index: i });
    });
  }
  
  // === ANTENNAE (long, flowing with physics) ===
  bodyParts.antennae = [];
  bodyParts.antennaChains = [];
  
  [-1, 1].forEach(side => {
    const antennaGroup = new THREE.Group();
    const segments = 12;
    
    for (let i = 0; i < segments; i++) {
      const thickness = 0.02 - i * 0.0012;
      const seg = new THREE.Mesh(
        new THREE.CylinderGeometry(thickness, thickness * 1.1, 0.15, 6),
        clawMat
      );
      antennaGroup.add(seg);
    }
    
    antennaGroup.position.set(0.9, 0.15, side * 0.12);
    lobsterGroup.add(antennaGroup);
    bodyParts.antennae.push(antennaGroup);
    
    const chain = new IKChain(segments, 0.14, new THREE.Vector3(0.9, 0.15, side * 0.12), { minAngle: -1.2, maxAngle: 1.2 });
    bodyParts.antennaChains.push({ chain, group: antennaGroup, side });
  });
  
  lobsterGroup.position.y = 0;
  scene.add(lobsterGroup);
}

function setupInteraction(canvas) {
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = ((e.clientX - rect.left) / rect.width - 0.5) * 2;
    mouseY = ((e.clientY - rect.top) / rect.height - 0.5) * 2;
  });
  
  canvas.addEventListener('click', () => {
    // Trigger claw snap
    bodyParts.claws.forEach(claw => {
      claw.userData.pincerGroup.userData.isSnapping = true;
      claw.userData.pincerGroup.userData.snapPhase = 0;
    });
    setMood('excited');
  });
  
  let isDragging = false, lastX = 0;
  canvas.addEventListener('mousedown', (e) => { isDragging = true; lastX = e.clientX; });
  canvas.addEventListener('mouseup', () => isDragging = false);
  canvas.addEventListener('mouseleave', () => isDragging = false);
  canvas.addEventListener('mousemove', (e) => {
    if (isDragging) {
      targetRotY += (e.clientX - lastX) * 0.01;
      lastX = e.clientX;
    }
  });
}

function setMood(m) {
  mood = m;
  document.getElementById('mood').textContent = { chill: 'Chill', excited: 'Hyped!', thinking: 'Thinking...', speaking: 'Speaking' }[m] || 'Chill';
  if (m === 'excited') setTimeout(() => { if (mood === 'excited') mood = 'chill'; }, 3000);
}

function animate() {
  requestAnimationFrame(animate);
  
  const delta = clock.getDelta();
  const time = clock.getElapsedTime();
  const speedMult = mood === 'excited' ? 2.5 : 1;
  
  if (!lobsterGroup) return;
  
  // Smooth rotation
  if (!window.isDragging) targetRotY += mouseX * 0.003;
  lobsterGroup.rotation.y += (targetRotY - lobsterGroup.rotation.y) * 0.05;
  lobsterGroup.rotation.x += (-mouseY * 0.2 - lobsterGroup.rotation.x) * 0.05;
  
  // Breathing/floating
  const breathe = Math.sin(time * 1.5 * speedMult) * 0.08;
  lobsterGroup.position.y = breathe;
  
  // === BODY WAVE ===
  bodyParts.bodySegments.forEach((seg, i) => {
    if (i > 0 && bodyParts.bodySoftBodies[i - 1]) {
      const soft = bodyParts.bodySoftBodies[i - 1];
      const parentPos = bodyParts.bodySegments[i - 1].position;
      soft.update(parentPos, delta);
    }
    const wave = Math.sin(time * 2 * speedMult + i * 0.5) * 0.02;
    seg.position.y = wave;
    seg.rotation.z = Math.sin(time * 1.5 * speedMult + i * 0.3) * 0.05;
  });
  
  // === EYE TRACKING ===
  bodyParts.eyes.forEach((eye, idx) => {
    const lookX = mouseX * 0.4;
    const lookY = -mouseY * 0.3;
    eye.rotation.y += (lookX - eye.rotation.y) * 0.1;
    eye.rotation.x += (lookY - eye.rotation.x) * 0.1;
    
    // Blinking
    if (Math.random() < 0.002) {
      const eyelid = eye.userData.eyelid;
      eye.scale.y = 0.1;
      setTimeout(() => { eye.scale.y = 1; }, 80);
    }
    
    // Eye bob
    eye.position.y = eye.userData.baseY + Math.sin(time * 3 + idx) * 0.01;
  });
  
  // === CLAW ANIMATION ===
  bodyParts.claws.forEach((claw, idx) => {
    const side = claw.userData.side;
    const pincer = claw.userData.pincerGroup;
    const topClaw = pincer.userData.topClaw;
    
    // Idle wave
    claw.rotation.x = Math.sin(time * 1.2 * speedMult + idx * Math.PI) * 0.15;
    claw.rotation.z = claw.userData.baseRotZ + Math.sin(time * 0.8 * speedMult) * 0.1 * side;
    
    // Snap animation
    if (pincer.userData.isSnapping) {
      pincer.userData.snapPhase += delta * 15;
      const snap = Math.sin(pincer.userData.snapPhase * 3) * 0.5;
      topClaw.rotation.z = Math.max(0, snap);
      
      if (pincer.userData.snapPhase > 2) {
        pincer.userData.isSnapping = false;
        topClaw.rotation.z = 0;
      }
    } else {
      // Idle pincer movement
      topClaw.rotation.z = Math.sin(time * 2 + idx) * 0.1;
    }
  });
  
  // === TAIL PHYSICS ===
  const tailTarget = new THREE.Vector3(
    -2.5 + Math.sin(time * speedMult) * 0.3,
    Math.sin(time * 1.5 * speedMult) * 0.2,
    Math.sin(time * 0.7 * speedMult) * 0.15
  );
  bodyParts.tailChain.solve(tailTarget, delta);
  const tailPositions = bodyParts.tailChain.getPositions();
  
  bodyParts.tailSegments.forEach((seg, i) => {
    if (tailPositions[i]) {
      seg.position.copy(tailPositions[i]);
      if (tailPositions[i + 1]) {
        const dir = tailPositions[i + 1].clone().sub(tailPositions[i]);
        seg.rotation.z = Math.PI / 2 + Math.atan2(dir.y, dir.x);
      }
      seg.position.y += Math.sin(time * 2 * speedMult + i * 0.4) * 0.03;
    }
  });
  
  // Tail fan follows last segment
  if (tailPositions[5]) {
    bodyParts.tailFan.position.copy(tailPositions[5]);
    bodyParts.tailFan.position.x -= 0.2;
    bodyParts.tailFan.rotation.z = Math.sin(time * 3 * speedMult) * 0.2;
  }
  
  // === LEG IK ===
  bodyParts.legChains.forEach(({ chain, group, side, index }, i) => {
    const walkPhase = time * 3 * speedMult + index * 0.8 + (side > 0 ? Math.PI : 0);
    const stepHeight = Math.max(0, Math.sin(walkPhase)) * 0.1;
    const stepForward = Math.cos(walkPhase) * 0.08;
    
    const target = chain.basePos.clone();
    target.y -= 0.4 + stepHeight;
    target.x += stepForward;
    target.z += side * (0.15 + Math.sin(time + i) * 0.05);
    
    chain.solve(target, delta);
    const positions = chain.getPositions();
    
    group.children.forEach((seg, j) => {
      if (positions[j] && positions[j + 1]) {
        const start = positions[j];
        const end = positions[j + 1];
        const mid = start.clone().add(end).multiplyScalar(0.5);
        seg.position.copy(mid).sub(chain.basePos);
        
        const dir = end.clone().sub(start);
        seg.rotation.z = Math.atan2(dir.y, Math.sqrt(dir.x * dir.x + dir.z * dir.z));
        seg.rotation.y = Math.atan2(dir.x, dir.z);
      }
    });
  });
  
  // === ANTENNAE FLOW ===
  bodyParts.antennaChains.forEach(({ chain, group, side }, idx) => {
    const flowTarget = new THREE.Vector3(
      1.8 + Math.sin(time * 0.5 + idx) * 0.4 + mouseX * 0.3,
      0.6 + Math.sin(time * 0.7 + idx * 2) * 0.3 - mouseY * 0.2,
      side * (0.5 + Math.sin(time * 0.3) * 0.2)
    );
    
    chain.solve(flowTarget, delta);
    const positions = chain.getPositions();
    
    group.children.forEach((seg, i) => {
      if (positions[i] && positions[i + 1]) {
        const start = positions[i];
        const end = positions[i + 1];
        seg.position.copy(start).sub(chain.basePos);
        
        const dir = end.clone().sub(start).normalize();
        seg.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
      }
    });
  });
  
  // === GLOW when speaking ===
  if (mood === 'speaking') {
    const pulse = (Math.sin(time * 12) + 1) / 2 * 0.4;
    lobsterGroup.traverse(obj => {
      if (obj.material && obj.material.emissiveIntensity !== undefined) {
        obj.material.emissiveIntensity = 0.15 + pulse;
      }
    });
  }
  
  renderer.render(scene, camera);
}

// ============ TERMINAL ============
const SID_BACKEND = 'http://165.232.132.170:3456';
const SID_URL = window.location.hostname.includes('trycloudflare') || window.location.port === '3456' ? '' : SID_BACKEND;
const AUTH_TOKEN = 'sid2026';
const output = document.getElementById('output');
const input = document.getElementById('input');
let audioPlayer = new Audio();
let audioUnlocked = false;

function unlockAudio() {
  if (audioUnlocked) return;
  audioPlayer.src = 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAD/+1DEAAAHAAGf9AAAIwAANIAAAARMQU1FMy4xMDBVVVVVVVVV';
  audioPlayer.play().then(() => { audioPlayer.pause(); audioUnlocked = true; log('üîä Audio enabled', 'system'); }).catch(() => {});
}
document.addEventListener('click', unlockAudio);
document.addEventListener('keydown', unlockAudio);

function log(text, type = '') {
  const line = document.createElement('div');
  line.className = `terminal-line ${type}`;
  const time = new Date().toLocaleTimeString('en-US', { hour12: false });
  line.innerHTML = `<span class="timestamp">[${time}]</span> ${text}`;
  output.appendChild(line);
  output.scrollTop = output.scrollHeight;
  while (output.children.length > 150) output.removeChild(output.firstChild);
}

function logSid(text) { log(`<span class="prefix">SID:</span> ${text}`, 'sid'); setMood('speaking'); }

async function speak(text) {
  log(`üéôÔ∏è "${text}"`, 'voice');
  setMood('speaking');
  try {
    const resp = await fetch(`${SID_URL}/speak?token=${AUTH_TOKEN}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text })
    });
    const data = await resp.json().catch(() => ({}));
    if (data.audioPath) {
      audioPlayer.src = `${SID_URL}${data.audioPath}`;
      audioPlayer.play().catch(e => log('Audio: ' + e.message, 'error'));
    }
  } catch (e) { log('Voice error: ' + e.message, 'error'); }
  setTimeout(() => setMood('chill'), text.split(' ').length * 250);
}

const commands = {
  help: () => log('Commands: gm, build, ship, hype, debug, deploy, test, clear', 'system'),
  gm: () => speak("GM! Coffee's ready, VS Code is open. Let's ship something."),
  build: () => { setMood('thinking'); speak("Alright, let's architect this. No spaghetti allowed."); },
  ship: () => { setMood('excited'); speak("Ship it! Done is better than perfect."); },
  hype: () => { setMood('excited'); speak("LET'S GOOO! We're shipping the future!"); },
  debug: () => { setMood('thinking'); speak("Rubber duck time. Walk me through it."); },
  deploy: () => { log('> Deploying...', 'system'); setTimeout(() => log('‚úì Deployed!', 'success'), 2000); },
  test: () => { log('> Running tests...', 'system'); setTimeout(() => log('‚úì All passed', 'success'), 1500); },
  clear: () => { output.innerHTML = ''; }
};

function cmd(text) { input.value = text; handleCommand(text); }
function handleCommand(text) {
  const [c] = text.trim().split(' ');
  log(`$ ${text}`, 'system');
  if (commands[c]) commands[c]();
  else if (text.trim()) speak(text);
}
input.addEventListener('keydown', (e) => { if (e.key === 'Enter' && input.value.trim()) { handleCommand(input.value); input.value = ''; } });

function connectSSE() {
  const es = new EventSource(`${SID_URL}/events`);
  es.onopen = () => { document.getElementById('connection').innerHTML = '<span style="color:#00ff41">‚óè</span> Connected'; };
  es.onmessage = (e) => { try { const d = JSON.parse(e.data); if (d.type === 'speak') logSid(d.text); if (d.type === 'audio') { audioPlayer.src = `${SID_URL}${d.path}`; audioPlayer.play().catch(() => {}); } } catch {} };
  es.onerror = () => setTimeout(connectSSE, 5000);
}

initLobster();
log('ü¶û SID v2.0 - Procedural Animation', 'system');
log('Click lobster to snap claws!', 'system');
connectSSE();
setInterval(() => { document.getElementById('time').textContent = new Date().toLocaleTimeString('en-US', { hour12: false }); }, 1000);
document.addEventListener('click', () => input.focus());
window.addEventListener('resize', () => { const c = document.getElementById('lobster-container'); camera.aspect = c.clientWidth / c.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(c.clientWidth, c.clientHeight); });
  </script>
</body>
</html>
