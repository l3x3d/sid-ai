<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SID ðŸ¦ž</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: linear-gradient(180deg, #1a2a4a 0%, #0d1a2d 50%, #0a1520 100%);
      font-family: 'Segoe UI', Tahoma, sans-serif;
      height: 100vh;
      overflow: hidden;
      display: flex;
    }
    
    /* Left side - Lobster */
    #lobster-section {
      flex: 1;
      position: relative;
      min-width: 400px;
    }
    #canvas { display: block; width: 100%; height: 100%; }
    
    #speech-box {
      position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
      background: rgba(255,255,255,0.95); border: 3px solid #ff6b4a; border-radius: 20px;
      padding: 15px 25px; color: #333; font-size: 18px; max-width: 400px; text-align: center;
      opacity: 0; transition: opacity 0.3s; z-index: 10; box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
    #speech-box.visible { opacity: 1; }
    
    #waveform-container {
      position: absolute; bottom: 30%; left: 50%; transform: translateX(-50%);
      width: 200px; height: 60px; display: none; z-index: 5;
    }
    #waveform-container.active { display: block; }
    #waveform { width: 100%; height: 100%; }
    
    /* Right side - Terminal */
    #terminal-section {
      width: 50%;
      max-width: 700px;
      display: flex;
      flex-direction: column;
      background: #0d0d0d;
      border-left: 1px solid #333;
    }
    
    #terminal-header {
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      border-bottom: 1px solid #333;
    }
    #terminal-header .dots { display: flex; gap: 6px; }
    #terminal-header .dot { width: 12px; height: 12px; border-radius: 50%; }
    #terminal-header .dot.red { background: #ff5f56; }
    #terminal-header .dot.yellow { background: #ffbd2e; }
    #terminal-header .dot.green { background: #27ca40; }
    #terminal-header .title { flex: 1; color: #888; font-size: 13px; text-align: center; }
    #terminal-header .status { color: #27ca40; font-size: 12px; display: flex; align-items: center; gap: 5px; }
    #terminal-header .status::before { content: ''; width: 6px; height: 6px; background: #27ca40; border-radius: 50%; animation: pulse 2s infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    
    #terminal-tabs {
      display: flex;
      background: #111;
      border-bottom: 1px solid #333;
    }
    .terminal-tab {
      padding: 10px 20px;
      color: #666;
      font-size: 13px;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
    }
    .terminal-tab:hover { color: #aaa; }
    .terminal-tab.active { color: #fff; border-bottom-color: #27ca40; background: #1a1a1a; }
    
    #terminal-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    #terminal-output {
      flex: 1;
      padding: 15px;
      overflow-y: auto;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 13px;
      line-height: 1.5;
      color: #0f0;
      background: #0a0a0a;
    }
    #terminal-output::-webkit-scrollbar { width: 8px; }
    #terminal-output::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
    
    .term-line { margin: 2px 0; white-space: pre-wrap; word-break: break-all; }
    .term-line.input { color: #0ff; }
    .term-line.output { color: #0f0; }
    .term-line.error { color: #f55; }
    .term-line.info { color: #888; }
    .term-line.success { color: #0f0; }
    .term-line.sid { color: #ff6b4a; }
    
    #terminal-input-area {
      display: flex;
      align-items: center;
      padding: 12px 15px;
      background: #111;
      border-top: 1px solid #333;
      gap: 10px;
    }
    #terminal-prompt { color: #27ca40; font-family: monospace; }
    #terminal-input {
      flex: 1;
      background: transparent;
      border: none;
      color: #fff;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 14px;
      outline: none;
    }
    
    /* Preview iframe */
    #preview-container {
      display: none;
      flex: 1;
      background: #fff;
    }
    #preview-container.active { display: block; }
    #preview-frame { width: 100%; height: 100%; border: none; }
    
    /* Chat toggle */
    #chat-toggle {
      position: fixed; bottom: 20px; left: 20px; width: 65px; height: 65px;
      background: linear-gradient(135deg, #ff6b4a, #ff8866); border: none; border-radius: 50%;
      cursor: pointer; font-size: 32px; color: white; box-shadow: 0 4px 20px rgba(255,107,74,0.5);
      transition: all 0.3s; z-index: 1000;
    }
    #chat-toggle:hover { transform: scale(1.1); }
    #chat-toggle.open { background: linear-gradient(135deg, #444, #666); }
    
    #chat-terminal {
      position: fixed; bottom: 100px; left: 20px; width: 360px; height: 420px;
      background: rgba(255,255,255,0.98); border-radius: 20px; display: none;
      flex-direction: column; z-index: 999; box-shadow: 0 15px 50px rgba(0,0,0,0.3);
    }
    #chat-terminal.open { display: flex; }
    
    #chat-header {
      background: linear-gradient(135deg, #ff6b4a, #ff8866); padding: 15px 18px;
      display: flex; align-items: center; gap: 12px; border-radius: 20px 20px 0 0;
    }
    #chat-header .avatar { font-size: 28px; }
    #chat-header .title { flex: 1; font-weight: 600; color: #fff; font-size: 16px; }
    #chat-header .close-btn { background: rgba(255,255,255,0.2); border: none; color: #fff; width: 28px; height: 28px; border-radius: 50%; cursor: pointer; }
    
    #chat-messages { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 10px; background: #f8f9fa; }
    .msg { max-width: 80%; padding: 10px 14px; border-radius: 18px; line-height: 1.4; font-size: 14px; }
    .msg.user { background: #ff6b4a; color: #fff; align-self: flex-end; }
    .msg.sid { background: #fff; color: #333; align-self: flex-start; box-shadow: 0 2px 8px rgba(0,0,0,0.08); }
    .msg.system { background: transparent; color: #888; font-size: 12px; align-self: center; }
    
    .typing { display: flex; gap: 5px; padding: 10px 14px; background: #fff; border-radius: 18px; }
    .typing span { width: 8px; height: 8px; background: #ff6b4a; border-radius: 50%; animation: bounce 1.4s infinite; }
    .typing span:nth-child(2) { animation-delay: 0.2s; }
    .typing span:nth-child(3) { animation-delay: 0.4s; }
    @keyframes bounce { 0%, 60%, 100% { transform: translateY(0); } 30% { transform: translateY(-6px); } }
    
    #chat-input-area { display: flex; gap: 10px; padding: 15px; background: #fff; border-top: 1px solid #eee; border-radius: 0 0 20px 20px; }
    #chat-input { flex: 1; background: #f0f2f5; border: none; border-radius: 24px; padding: 12px 18px; font-size: 14px; outline: none; }
    #send-btn { background: #ff6b4a; border: none; color: white; width: 44px; height: 44px; border-radius: 50%; cursor: pointer; font-size: 18px; }
    
    #audio-player { display: none; }
    
    /* Loading overlay */
    #loading-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(10, 21, 32, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      transition: opacity 0.5s;
    }
    #loading-overlay.hidden { opacity: 0; pointer-events: none; }
    #loading-text { color: #fff; font-size: 18px; margin-top: 20px; }
    #loading-sub { color: #888; font-size: 14px; margin-top: 8px; }
    .loader {
      width: 60px; height: 60px;
      border: 4px solid #333;
      border-top-color: #27ca40;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <!-- Loading overlay -->
  <div id="loading-overlay">
    <div class="loader"></div>
    <div id="loading-text">ðŸ¦ž Booting SID's workspace...</div>
    <div id="loading-sub">Starting WebContainer</div>
  </div>

  <!-- Lobster section -->
  <div id="lobster-section">
    <canvas id="canvas"></canvas>
    <div id="speech-box"></div>
    <div id="waveform-container"><canvas id="waveform"></canvas></div>
  </div>
  
  <!-- Terminal section -->
  <div id="terminal-section">
    <div id="terminal-header">
      <div class="dots">
        <div class="dot red"></div>
        <div class="dot yellow"></div>
        <div class="dot green"></div>
      </div>
      <div class="title">SID's Workspace</div>
      <div class="status">WebContainer</div>
    </div>
    <div id="terminal-tabs">
      <div class="terminal-tab active" data-tab="terminal">Terminal</div>
      <div class="terminal-tab" data-tab="preview">Preview</div>
    </div>
    <div id="terminal-content">
      <div id="terminal-output"></div>
      <div id="preview-container"><iframe id="preview-frame"></iframe></div>
    </div>
    <div id="terminal-input-area">
      <span id="terminal-prompt">$</span>
      <input type="text" id="terminal-input" placeholder="Type a command or ask SID to build something..." autocomplete="off">
    </div>
  </div>
  
  <audio id="audio-player"></audio>
  <button id="chat-toggle" onclick="toggleChat()">ðŸ¦ž</button>
  
  <div id="chat-terminal">
    <div id="chat-header">
      <span class="avatar">ðŸ¦ž</span>
      <span class="title">Chat with Sid</span>
      <button class="close-btn" onclick="toggleChat()">âœ•</button>
    </div>
    <div id="chat-messages"><div class="msg system">Ask Sid to build something!</div></div>
    <div id="chat-input-area">
      <input type="text" id="chat-input" placeholder="Build me a..." autocomplete="off">
      <button id="send-btn">âž¤</button>
    </div>
  </div>

  <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js","@webcontainer/api":"https://esm.sh/@webcontainer/api"}}</script>
  <script type="module">
    import * as THREE from 'three';
    import { WebContainer } from '@webcontainer/api';
    
    let chatOpen = false, isSpeaking = false, speakingTime = 0;
    let audioContext, analyser, dataArray;
    let webcontainer = null;
    let currentProcess = null;
    
    // ============ WEBCONTAINER ============
    const termOutput = document.getElementById('terminal-output');
    const termInput = document.getElementById('terminal-input');
    const loadingOverlay = document.getElementById('loading-overlay');
    const loadingSub = document.getElementById('loading-sub');
    const previewFrame = document.getElementById('preview-frame');
    const previewContainer = document.getElementById('preview-container');
    
    function termLog(text, type = 'output') {
      const line = document.createElement('div');
      line.className = `term-line ${type}`;
      line.textContent = text;
      termOutput.appendChild(line);
      termOutput.scrollTop = termOutput.scrollHeight;
    }
    
    async function bootWebContainer() {
      try {
        loadingSub.textContent = 'Initializing WebContainer...';
        webcontainer = await WebContainer.boot();
        
        loadingSub.textContent = 'Setting up filesystem...';
        await webcontainer.mount({
          'package.json': {
            file: { contents: JSON.stringify({
              name: 'sid-workspace',
              type: 'module',
              scripts: { start: 'node index.js', dev: 'npx vite' }
            }, null, 2) }
          },
          'index.js': {
            file: { contents: '// SID\\'s workspace - ready to build!\\nconsole.log("ðŸ¦ž SID workspace ready!");\\n' }
          }
        });
        
        // Listen for server-ready events
        webcontainer.on('server-ready', (port, url) => {
          termLog(`ðŸŒ Server ready at ${url}`, 'success');
          previewFrame.src = url;
        });
        
        loadingSub.textContent = 'Ready!';
        setTimeout(() => loadingOverlay.classList.add('hidden'), 500);
        
        termLog('ðŸ¦ž SID WebContainer ready!', 'sid');
        termLog('Type commands or ask me to build something.', 'info');
        termLog('', 'info');
        
      } catch (e) {
        console.error('WebContainer boot failed:', e);
        loadingSub.textContent = 'Failed to boot - ' + e.message;
        termLog('âŒ WebContainer failed: ' + e.message, 'error');
      }
    }
    
    async function runCommand(cmd) {
      if (!webcontainer) {
        termLog('WebContainer not ready', 'error');
        return;
      }
      
      termLog(`$ ${cmd}`, 'input');
      
      const parts = cmd.split(' ');
      const command = parts[0];
      const args = parts.slice(1);
      
      try {
        const process = await webcontainer.spawn(command, args);
        currentProcess = process;
        
        process.output.pipeTo(new WritableStream({
          write(data) { 
            data.split('\\n').forEach(line => {
              if (line.trim()) termLog(line, 'output');
            });
          }
        }));
        
        const exitCode = await process.exit;
        if (exitCode !== 0) {
          termLog(`Process exited with code ${exitCode}`, 'error');
        }
        currentProcess = null;
      } catch (e) {
        termLog(`Error: ${e.message}`, 'error');
      }
    }
    
    async function writeFile(path, contents) {
      if (!webcontainer) return;
      await webcontainer.fs.writeFile(path, contents);
      termLog(`ðŸ“ Wrote ${path}`, 'success');
    }
    
    // Terminal input handler
    termInput.addEventListener('keypress', async (e) => {
      if (e.key === 'Enter') {
        const cmd = termInput.value.trim();
        termInput.value = '';
        if (!cmd) return;
        
        // Check if it's a build request for SID
        if (cmd.toLowerCase().startsWith('build ') || cmd.toLowerCase().startsWith('create ') || cmd.toLowerCase().startsWith('make ')) {
          await askSidToBuild(cmd);
        } else {
          await runCommand(cmd);
        }
      }
    });
    
    // Tab switching
    document.querySelectorAll('.terminal-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.terminal-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        const tabName = tab.dataset.tab;
        if (tabName === 'preview') {
          previewContainer.classList.add('active');
          termOutput.style.display = 'none';
        } else {
          previewContainer.classList.remove('active');
          termOutput.style.display = 'block';
        }
      });
    });
    
    // Ask SID to build something
    async function askSidToBuild(request) {
      termLog(`ðŸ¦ž SID: "${request}"... let me cook!`, 'sid');
      
      try {
        const resp = await fetch('/api/build', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ request })
        });
        
        const { files, commands, message } = await resp.json();
        
        if (message) {
          termLog(`ðŸ¦ž ${message}`, 'sid');
          showSpeech(message);
        }
        
        // Write files
        if (files) {
          for (const [path, contents] of Object.entries(files)) {
            await writeFile(path, contents);
          }
        }
        
        // Run commands
        if (commands) {
          for (const cmd of commands) {
            await runCommand(cmd);
          }
        }
        
      } catch (e) {
        termLog(`ðŸ¦ž Oops, hit a snag: ${e.message}`, 'error');
      }
    }
    
    // Boot on load
    bootWebContainer();
    
    // ============ CHAT ============
    window.toggleChat = function() {
      chatOpen = !chatOpen;
      document.getElementById('chat-terminal').classList.toggle('open', chatOpen);
      document.getElementById('chat-toggle').classList.toggle('open', chatOpen);
      document.getElementById('chat-toggle').textContent = chatOpen ? 'âœ•' : 'ðŸ¦ž';
      if (chatOpen) document.getElementById('chat-input').focus();
    };
    
    // ============ WAVEFORM ============
    const waveformContainer = document.getElementById('waveform-container');
    const waveformCanvas = document.getElementById('waveform');
    const waveCtx = waveformCanvas.getContext('2d');
    waveformCanvas.width = 200;
    waveformCanvas.height = 60;
    
    function drawWaveform() {
      if (!isSpeaking || !analyser) {
        waveformContainer.classList.remove('active');
        return;
      }
      waveformContainer.classList.add('active');
      analyser.getByteFrequencyData(dataArray);
      waveCtx.clearRect(0, 0, 200, 60);
      const bars = 20, barWidth = 6, gap = 4;
      const startX = (200 - (bars * (barWidth + gap))) / 2;
      for (let i = 0; i < bars; i++) {
        const value = dataArray[Math.floor(i * dataArray.length / bars)] / 255;
        const height = Math.max(4, value * 50);
        const gradient = waveCtx.createLinearGradient(0, 30 - height/2, 0, 30 + height/2);
        gradient.addColorStop(0, '#00ff88');
        gradient.addColorStop(1, '#00ff88');
        waveCtx.fillStyle = gradient;
        waveCtx.shadowColor = '#00ff88';
        waveCtx.shadowBlur = 10;
        waveCtx.beginPath();
        waveCtx.roundRect(startX + i * (barWidth + gap), 30 - height/2, barWidth, height, 3);
        waveCtx.fill();
      }
      requestAnimationFrame(drawWaveform);
    }
    
    // ============ THREE.JS LOBSTER ============
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(canvas.parentElement.clientWidth, canvas.parentElement.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(40, canvas.parentElement.clientWidth / canvas.parentElement.clientHeight, 0.1, 100);
    camera.position.set(0, 0, 5);
    
    window.addEventListener('resize', () => {
      const w = canvas.parentElement.clientWidth, h = canvas.parentElement.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });
    
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const keyLight = new THREE.DirectionalLight(0xfff8f0, 1);
    keyLight.position.set(2, 3, 4);
    scene.add(keyLight);
    scene.add(new THREE.DirectionalLight(0xff9966, 0.4).translateX(-3));
    
    const lobster = new THREE.Group();
    scene.add(lobster);
    
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff6b4a, roughness: 0.4 });
    const lightMat = new THREE.MeshStandardMaterial({ color: 0xff8866, roughness: 0.35 });
    const darkMat = new THREE.MeshStandardMaterial({ color: 0xdd5544, roughness: 0.45 });
    const eyeWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 });
    const pupilMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.1 });
    const cheekMat = new THREE.MeshStandardMaterial({ color: 0xffaaaa, roughness: 0.5 });
    
    const bodyGeom = new THREE.SphereGeometry(1, 32, 32);
    bodyGeom.scale(1.1, 0.9, 1);
    lobster.add(new THREE.Mesh(bodyGeom, bodyMat));
    
    const cheekGeom = new THREE.SphereGeometry(0.2, 16, 16);
    const lCheek = new THREE.Mesh(cheekGeom, cheekMat); lCheek.position.set(-0.55, -0.1, 0.7); lobster.add(lCheek);
    const rCheek = new THREE.Mesh(cheekGeom, cheekMat); rCheek.position.set(0.55, -0.1, 0.7); lobster.add(rCheek);
    
    const stalkGeom = new THREE.CylinderGeometry(0.08, 0.1, 0.25, 12);
    const lStalk = new THREE.Mesh(stalkGeom, bodyMat); lStalk.position.set(-0.35, 0.55, 0.6); lStalk.rotation.set(-0.3, 0, -0.2); lobster.add(lStalk);
    const rStalk = new THREE.Mesh(stalkGeom, bodyMat); rStalk.position.set(0.35, 0.55, 0.6); rStalk.rotation.set(-0.3, 0, 0.2); lobster.add(rStalk);
    
    const eyeGeom = new THREE.SphereGeometry(0.22, 24, 24);
    const lEye = new THREE.Mesh(eyeGeom, eyeWhiteMat); lEye.position.set(-0.4, 0.7, 0.75); lobster.add(lEye);
    const rEye = new THREE.Mesh(eyeGeom, eyeWhiteMat); rEye.position.set(0.4, 0.7, 0.75); lobster.add(rEye);
    
    const pupilGeom = new THREE.SphereGeometry(0.1, 16, 16);
    const lPupil = new THREE.Mesh(pupilGeom, pupilMat); lPupil.position.set(-0.4, 0.72, 0.95); lobster.add(lPupil);
    const rPupil = new THREE.Mesh(pupilGeom, pupilMat); rPupil.position.set(0.4, 0.72, 0.95); lobster.add(rPupil);
    
    const highlightMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const highlightGeom = new THREE.SphereGeometry(0.04, 8, 8);
    const lHighlight = new THREE.Mesh(highlightGeom, highlightMat); lHighlight.position.set(-0.35, 0.78, 0.98); lobster.add(lHighlight);
    const rHighlight = new THREE.Mesh(highlightGeom, highlightMat); rHighlight.position.set(0.45, 0.78, 0.98); lobster.add(rHighlight);
    
    function makeAntenna(xSign) {
      const g = new THREE.Group();
      const curve = new THREE.CatmullRomCurve3([new THREE.Vector3(0,0,0), new THREE.Vector3(xSign*0.3,0.5,0.2), new THREE.Vector3(xSign*0.5,1.2,0), new THREE.Vector3(xSign*0.4,1.8,-0.2)]);
      g.add(new THREE.Mesh(new THREE.TubeGeometry(curve, 20, 0.03, 8, false), darkMat));
      const tip = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), lightMat); tip.position.set(xSign*0.4, 1.8, -0.2); g.add(tip);
      return g;
    }
    const lAnt = makeAntenna(-1); lAnt.position.set(-0.15, 0.5, 0.7); lobster.add(lAnt);
    const rAnt = makeAntenna(1); rAnt.position.set(0.15, 0.5, 0.7); lobster.add(rAnt);
    
    const smileCurve = new THREE.EllipseCurve(0, 0, 0.25, 0.12, 0, Math.PI, false, 0);
    const smile = new THREE.Line(new THREE.BufferGeometry().setFromPoints(smileCurve.getPoints(20)), new THREE.LineBasicMaterial({ color: 0x993322 }));
    smile.position.set(0, -0.25, 1.0); smile.rotation.z = Math.PI; lobster.add(smile);
    
    function makeClaw(xSign) {
      const g = new THREE.Group();
      const arm = new THREE.Mesh(new THREE.CapsuleGeometry(0.08, 0.4, 8, 8), bodyMat); arm.rotation.z = xSign * 0.6; g.add(arm);
      const claw = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), lightMat); claw.scale.set(1.2, 0.8, 1); claw.position.set(xSign * 0.35, -0.1, 0); g.add(claw);
      return g;
    }
    const lClaw = makeClaw(-1); lClaw.position.set(-0.7, -0.3, 0.3); lobster.add(lClaw);
    const rClaw = makeClaw(1); rClaw.position.set(0.7, -0.3, 0.3); lobster.add(rClaw);
    
    const mouse = { x: 0, y: 0 };
    let blinkTimer = 0, isBlinking = false;
    document.addEventListener('mousemove', e => { mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1; });
    
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta(), t = clock.getElapsedTime();
      
      lobster.rotation.y = Math.sin(t * 0.5) * 0.1;
      lobster.rotation.x = Math.sin(t * 0.3) * 0.03;
      lobster.position.y = Math.sin(t * 0.7) * 0.05;
      
      lPupil.position.x = -0.4 + mouse.x * 0.06;
      lPupil.position.y = 0.72 + mouse.y * 0.04;
      rPupil.position.x = 0.4 + mouse.x * 0.06;
      rPupil.position.y = 0.72 + mouse.y * 0.04;
      
      blinkTimer += delta;
      if (!isBlinking && blinkTimer > 3 + Math.random() * 2) { isBlinking = true; blinkTimer = 0; }
      if (isBlinking) {
        const p = blinkTimer * 10, s = p < 1 ? 1 - p : (p < 2 ? p - 1 : 1);
        lEye.scale.y = rEye.scale.y = lPupil.scale.y = rPupil.scale.y = s;
        lHighlight.visible = rHighlight.visible = s > 0.5;
        if (p > 2) isBlinking = false;
      }
      
      lAnt.rotation.z = Math.sin(t * 1.5) * 0.1;
      rAnt.rotation.z = Math.sin(t * 1.5 + 0.5) * 0.1;
      
      if (isSpeaking) { speakingTime += delta; lClaw.rotation.z = Math.sin(speakingTime * 6) * 0.15; rClaw.rotation.z = Math.sin(speakingTime * 6 + 1) * 0.15; }
      else { lClaw.rotation.z *= 0.95; rClaw.rotation.z *= 0.95; }
      
      renderer.render(scene, camera);
    }
    animate();
    
    // ============ CHAT LOGIC ============
    const msgBox = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');
    const speechBox = document.getElementById('speech-box');
    const audioPlayer = document.getElementById('audio-player');
    
    function addMsg(text, type) { const div = document.createElement('div'); div.className = `msg ${type}`; div.textContent = text; msgBox.appendChild(div); msgBox.scrollTop = msgBox.scrollHeight; }
    function showSpeech(text) { speechBox.textContent = text; speechBox.classList.add('visible'); isSpeaking = true; speakingTime = 0; setTimeout(() => { speechBox.classList.remove('visible'); isSpeaking = false; }, 4000); }
    function hideSpeech() { speechBox.classList.remove('visible'); isSpeaking = false; waveformContainer.classList.remove('active'); }
    
    async function sendChat() {
      const text = chatInput.value.trim();
      if (!text) return;
      chatInput.value = '';
      sendBtn.disabled = true;
      addMsg(text, 'user');
      
      // Check if it's a build request
      if (text.toLowerCase().includes('build') || text.toLowerCase().includes('create') || text.toLowerCase().includes('make')) {
        addMsg("On it! Check the terminal ðŸ‘‰", 'sid');
        showSpeech("Let me cook something up! ðŸ¦ž");
        await askSidToBuild(text);
      } else {
        // Regular chat
        try {
          const resp = await fetch('/api/chat', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: text }) });
          const { reply } = await resp.json();
          addMsg(reply, 'sid');
          showSpeech(reply);
        } catch {
          addMsg("Oops, brain freeze! ðŸ¦ž", 'sid');
        }
      }
      sendBtn.disabled = false;
      chatInput.focus();
    }
    
    sendBtn.onclick = sendChat;
    chatInput.onkeypress = e => { if (e.key === 'Enter') sendChat(); };
  </script>
</body>
</html>
