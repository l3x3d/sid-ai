<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SID ðŸ¦ž</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: linear-gradient(180deg, #1a2a4a 0%, #0d1a2d 50%, #0a1520 100%);
      font-family: 'Segoe UI', Tahoma, sans-serif;
      height: 100vh;
      overflow: hidden;
    }
    #canvas { display: block; width: 100%; height: 100%; }
    
    #speech-box {
      position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
      background: rgba(255,255,255,0.95); border: 3px solid #ff6b4a; border-radius: 20px;
      padding: 15px 25px; color: #333; font-size: 18px; max-width: 500px; text-align: center;
      opacity: 0; transition: opacity 0.3s; z-index: 10; box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
    #speech-box.visible { opacity: 1; }
    #speech-box::after { content: ''; position: absolute; bottom: -15px; left: 50%; transform: translateX(-50%); border: 15px solid transparent; border-top-color: #ff6b4a; }
    
    /* Waveform */
    #waveform-container {
      position: absolute; bottom: 35%; left: 50%; transform: translateX(-50%);
      width: 200px; height: 60px; display: none; z-index: 5;
    }
    #waveform-container.active { display: block; }
    #waveform { width: 100%; height: 100%; }
    
    #chat-toggle {
      position: fixed; bottom: 20px; right: 20px; width: 65px; height: 65px;
      background: linear-gradient(135deg, #ff6b4a, #ff8866); border: none; border-radius: 50%;
      cursor: pointer; font-size: 32px; color: white; box-shadow: 0 4px 20px rgba(255,107,74,0.5);
      transition: all 0.3s; z-index: 1000;
    }
    #chat-toggle:hover { transform: scale(1.1); }
    #chat-toggle.open { background: linear-gradient(135deg, #444, #666); }
    
    #chat-terminal {
      position: fixed; bottom: 100px; right: 20px; width: 360px; height: 420px;
      background: rgba(255,255,255,0.98); border-radius: 20px; display: none;
      flex-direction: column; z-index: 999; box-shadow: 0 15px 50px rgba(0,0,0,0.3);
    }
    #chat-terminal.open { display: flex; }
    
    #chat-header {
      background: linear-gradient(135deg, #ff6b4a, #ff8866); padding: 15px 18px;
      display: flex; align-items: center; gap: 12px; border-radius: 20px 20px 0 0;
    }
    #chat-header .avatar { font-size: 28px; }
    #chat-header .title { flex: 1; font-weight: 600; color: #fff; font-size: 16px; }
    #chat-header .status { font-size: 11px; color: #c8ffcc; display: flex; align-items: center; gap: 4px; }
    #chat-header .status::before { content: ''; width: 8px; height: 8px; background: #88ff88; border-radius: 50%; }
    #chat-header .close-btn { background: rgba(255,255,255,0.2); border: none; color: #fff; width: 28px; height: 28px; border-radius: 50%; cursor: pointer; }
    
    #chat-messages { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 10px; background: #f8f9fa; }
    .msg { max-width: 80%; padding: 10px 14px; border-radius: 18px; line-height: 1.4; font-size: 14px; animation: fadeIn 0.2s; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; } }
    .msg.user { background: #ff6b4a; color: #fff; align-self: flex-end; border-bottom-right-radius: 6px; }
    .msg.sid { background: #fff; color: #333; align-self: flex-start; border-bottom-left-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); }
    .msg.system { background: transparent; color: #888; font-size: 12px; text-align: center; align-self: center; }
    
    .typing { display: flex; gap: 5px; padding: 10px 14px; background: #fff; border-radius: 18px; }
    .typing span { width: 8px; height: 8px; background: #ff6b4a; border-radius: 50%; animation: bounce 1.4s infinite; }
    .typing span:nth-child(2) { animation-delay: 0.2s; }
    .typing span:nth-child(3) { animation-delay: 0.4s; }
    @keyframes bounce { 0%, 60%, 100% { transform: translateY(0); } 30% { transform: translateY(-6px); } }
    
    #chat-input-area { display: flex; gap: 10px; padding: 15px; background: #fff; border-top: 1px solid #eee; border-radius: 0 0 20px 20px; }
    #chat-input { flex: 1; background: #f0f2f5; border: none; border-radius: 24px; padding: 12px 18px; font-size: 14px; outline: none; }
    #chat-input:focus { background: #e8eaed; }
    #send-btn { background: #ff6b4a; border: none; color: white; width: 44px; height: 44px; border-radius: 50%; cursor: pointer; font-size: 18px; }
    #send-btn:hover { background: #ff8866; }
    #send-btn:disabled { background: #ccc; }
    #audio-player { display: none; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="speech-box"></div>
  
  <!-- Waveform visualization -->
  <div id="waveform-container">
    <canvas id="waveform"></canvas>
  </div>
  
  <audio id="audio-player"></audio>
  <button id="chat-toggle" onclick="toggleChat()">ðŸ¦ž</button>
  <div id="chat-terminal">
    <div id="chat-header">
      <span class="avatar">ðŸ¦ž</span>
      <span class="title">Sid</span>
      <span class="status">online</span>
      <button class="close-btn" onclick="toggleChat()">âœ•</button>
    </div>
    <div id="chat-messages"><div class="msg system">Say hi to Sid! ðŸ‘‹</div></div>
    <div id="chat-input-area">
      <input type="text" id="chat-input" placeholder="Type a message..." autocomplete="off">
      <button id="send-btn">âž¤</button>
    </div>
  </div>

  <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js"}}</script>
  <script type="module">
    import * as THREE from 'three';
    
    let chatOpen = false, isSpeaking = false, speakingTime = 0;
    let audioContext, analyser, dataArray;
    
    window.toggleChat = function() {
      chatOpen = !chatOpen;
      document.getElementById('chat-terminal').classList.toggle('open', chatOpen);
      document.getElementById('chat-toggle').classList.toggle('open', chatOpen);
      document.getElementById('chat-toggle').textContent = chatOpen ? 'âœ•' : 'ðŸ¦ž';
      if (chatOpen) document.getElementById('chat-input').focus();
    };
    
    // ============ WAVEFORM ============
    const waveformContainer = document.getElementById('waveform-container');
    const waveformCanvas = document.getElementById('waveform');
    const waveCtx = waveformCanvas.getContext('2d');
    waveformCanvas.width = 200;
    waveformCanvas.height = 60;
    
    function drawWaveform() {
      if (!isSpeaking || !analyser) {
        waveformContainer.classList.remove('active');
        return;
      }
      
      waveformContainer.classList.add('active');
      analyser.getByteFrequencyData(dataArray);
      
      waveCtx.clearRect(0, 0, 200, 60);
      
      const bars = 20;
      const barWidth = 6;
      const gap = 4;
      const startX = (200 - (bars * (barWidth + gap))) / 2;
      
      for (let i = 0; i < bars; i++) {
        const dataIndex = Math.floor(i * dataArray.length / bars);
        const value = dataArray[dataIndex] / 255;
        const height = Math.max(4, value * 50);
        
        const gradient = waveCtx.createLinearGradient(0, 30 - height/2, 0, 30 + height/2);
        gradient.addColorStop(0, '#00ff88');
        gradient.addColorStop(0.5, '#00ffaa');
        gradient.addColorStop(1, '#00ff88');
        
        waveCtx.fillStyle = gradient;
        waveCtx.shadowColor = '#00ff88';
        waveCtx.shadowBlur = 10;
        waveCtx.beginPath();
        waveCtx.roundRect(startX + i * (barWidth + gap), 30 - height/2, barWidth, height, 3);
        waveCtx.fill();
      }
      
      requestAnimationFrame(drawWaveform);
    }
    
    // ============ THREE.JS ============
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 5);
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const keyLight = new THREE.DirectionalLight(0xfff8f0, 1);
    keyLight.position.set(2, 3, 4);
    scene.add(keyLight);
    scene.add(new THREE.DirectionalLight(0xff9966, 0.4).translateX(-3));
    
    const lobster = new THREE.Group();
    scene.add(lobster);
    
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff6b4a, roughness: 0.4 });
    const lightMat = new THREE.MeshStandardMaterial({ color: 0xff8866, roughness: 0.35 });
    const darkMat = new THREE.MeshStandardMaterial({ color: 0xdd5544, roughness: 0.45 });
    const eyeWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 });
    const pupilMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.1 });
    const cheekMat = new THREE.MeshStandardMaterial({ color: 0xffaaaa, roughness: 0.5 });
    
    const bodyGeom = new THREE.SphereGeometry(1, 32, 32);
    bodyGeom.scale(1.1, 0.9, 1);
    lobster.add(new THREE.Mesh(bodyGeom, bodyMat));
    
    const cheekGeom = new THREE.SphereGeometry(0.2, 16, 16);
    const lCheek = new THREE.Mesh(cheekGeom, cheekMat); lCheek.position.set(-0.55, -0.1, 0.7); lobster.add(lCheek);
    const rCheek = new THREE.Mesh(cheekGeom, cheekMat); rCheek.position.set(0.55, -0.1, 0.7); lobster.add(rCheek);
    
    const stalkGeom = new THREE.CylinderGeometry(0.08, 0.1, 0.25, 12);
    const lStalk = new THREE.Mesh(stalkGeom, bodyMat); lStalk.position.set(-0.35, 0.55, 0.6); lStalk.rotation.set(-0.3, 0, -0.2); lobster.add(lStalk);
    const rStalk = new THREE.Mesh(stalkGeom, bodyMat); rStalk.position.set(0.35, 0.55, 0.6); rStalk.rotation.set(-0.3, 0, 0.2); lobster.add(rStalk);
    
    const eyeGeom = new THREE.SphereGeometry(0.22, 24, 24);
    const lEye = new THREE.Mesh(eyeGeom, eyeWhiteMat); lEye.position.set(-0.4, 0.7, 0.75); lobster.add(lEye);
    const rEye = new THREE.Mesh(eyeGeom, eyeWhiteMat); rEye.position.set(0.4, 0.7, 0.75); lobster.add(rEye);
    
    const pupilGeom = new THREE.SphereGeometry(0.1, 16, 16);
    const lPupil = new THREE.Mesh(pupilGeom, pupilMat); lPupil.position.set(-0.4, 0.72, 0.95); lobster.add(lPupil);
    const rPupil = new THREE.Mesh(pupilGeom, pupilMat); rPupil.position.set(0.4, 0.72, 0.95); lobster.add(rPupil);
    
    const highlightMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const highlightGeom = new THREE.SphereGeometry(0.04, 8, 8);
    const lHighlight = new THREE.Mesh(highlightGeom, highlightMat); lHighlight.position.set(-0.35, 0.78, 0.98); lobster.add(lHighlight);
    const rHighlight = new THREE.Mesh(highlightGeom, highlightMat); rHighlight.position.set(0.45, 0.78, 0.98); lobster.add(rHighlight);
    
    function makeAntenna(xSign) {
      const g = new THREE.Group();
      const curve = new THREE.CatmullRomCurve3([new THREE.Vector3(0,0,0), new THREE.Vector3(xSign*0.3,0.5,0.2), new THREE.Vector3(xSign*0.5,1.2,0), new THREE.Vector3(xSign*0.4,1.8,-0.2)]);
      g.add(new THREE.Mesh(new THREE.TubeGeometry(curve, 20, 0.03, 8, false), darkMat));
      const tip = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), lightMat); tip.position.set(xSign*0.4, 1.8, -0.2); g.add(tip);
      return g;
    }
    const lAnt = makeAntenna(-1); lAnt.position.set(-0.15, 0.5, 0.7); lobster.add(lAnt);
    const rAnt = makeAntenna(1); rAnt.position.set(0.15, 0.5, 0.7); lobster.add(rAnt);
    
    const smileCurve = new THREE.EllipseCurve(0, 0, 0.25, 0.12, 0, Math.PI, false, 0);
    const smile = new THREE.Line(new THREE.BufferGeometry().setFromPoints(smileCurve.getPoints(20)), new THREE.LineBasicMaterial({ color: 0x993322 }));
    smile.position.set(0, -0.25, 1.0); smile.rotation.z = Math.PI; lobster.add(smile);
    
    function makeClaw(xSign) {
      const g = new THREE.Group();
      const arm = new THREE.Mesh(new THREE.CapsuleGeometry(0.08, 0.4, 8, 8), bodyMat); arm.rotation.z = xSign * 0.6; g.add(arm);
      const claw = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), lightMat); claw.scale.set(1.2, 0.8, 1); claw.position.set(xSign * 0.35, -0.1, 0); g.add(claw);
      return g;
    }
    const lClaw = makeClaw(-1); lClaw.position.set(-0.7, -0.3, 0.3); lobster.add(lClaw);
    const rClaw = makeClaw(1); rClaw.position.set(0.7, -0.3, 0.3); lobster.add(rClaw);
    
    const mouse = { x: 0, y: 0 };
    let blinkTimer = 0, isBlinking = false;
    document.addEventListener('mousemove', e => { mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1; });
    
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta(), t = clock.getElapsedTime();
      
      lobster.rotation.y = Math.sin(t * 0.5) * 0.1;
      lobster.rotation.x = Math.sin(t * 0.3) * 0.03;
      lobster.position.y = Math.sin(t * 0.7) * 0.05;
      
      lPupil.position.x = -0.4 + mouse.x * 0.06;
      lPupil.position.y = 0.72 + mouse.y * 0.04;
      rPupil.position.x = 0.4 + mouse.x * 0.06;
      rPupil.position.y = 0.72 + mouse.y * 0.04;
      
      blinkTimer += delta;
      if (!isBlinking && blinkTimer > 3 + Math.random() * 2) { isBlinking = true; blinkTimer = 0; }
      if (isBlinking) {
        const p = blinkTimer * 10, s = p < 1 ? 1 - p : (p < 2 ? p - 1 : 1);
        lEye.scale.y = rEye.scale.y = lPupil.scale.y = rPupil.scale.y = s;
        lHighlight.visible = rHighlight.visible = s > 0.5;
        if (p > 2) isBlinking = false;
      }
      
      lAnt.rotation.z = Math.sin(t * 1.5) * 0.1;
      rAnt.rotation.z = Math.sin(t * 1.5 + 0.5) * 0.1;
      
      if (isSpeaking) { speakingTime += delta; lClaw.rotation.z = Math.sin(speakingTime * 6) * 0.15; rClaw.rotation.z = Math.sin(speakingTime * 6 + 1) * 0.15; }
      else { lClaw.rotation.z *= 0.95; rClaw.rotation.z *= 0.95; }
      
      renderer.render(scene, camera);
    }
    animate();
    
    // ============ CHAT ============
    const msgBox = document.getElementById('chat-messages');
    const input = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');
    const speechBox = document.getElementById('speech-box');
    const audioPlayer = document.getElementById('audio-player');
    
    function addMsg(text, type) { const div = document.createElement('div'); div.className = `msg ${type}`; div.textContent = text; msgBox.appendChild(div); msgBox.scrollTop = msgBox.scrollHeight; }
    function showSpeech(text) { speechBox.textContent = text; speechBox.classList.add('visible'); isSpeaking = true; speakingTime = 0; }
    function hideSpeech() { speechBox.classList.remove('visible'); isSpeaking = false; waveformContainer.classList.remove('active'); }
    
    async function playVoice(text) {
      try {
        const voiceResp = await fetch('/api/voice', { 
          method: 'POST', 
          headers: { 'Content-Type': 'application/json' }, 
          body: JSON.stringify({ text }) 
        });
        
        if (!voiceResp.ok) { setTimeout(hideSpeech, 2000); return; }
        
        const blob = await voiceResp.blob();
        const url = URL.createObjectURL(blob);
        
        // Setup audio context for visualization
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 64;
          dataArray = new Uint8Array(analyser.frequencyBinCount);
        }
        
        audioPlayer.src = url;
        
        // Connect audio to analyser
        const source = audioContext.createMediaElementSource(audioPlayer);
        source.connect(analyser);
        analyser.connect(audioContext.destination);
        
        audioPlayer.onplay = () => { drawWaveform(); };
        audioPlayer.onended = () => { hideSpeech(); URL.revokeObjectURL(url); };
        
        await audioPlayer.play();
      } catch (e) {
        console.error('Voice error:', e);
        setTimeout(hideSpeech, 2000);
      }
    }
    
    async function send() {
      const text = input.value.trim();
      if (!text) return;
      input.value = '';
      sendBtn.disabled = true;
      addMsg(text, 'user');
      
      const typing = document.createElement('div');
      typing.className = 'msg sid typing';
      typing.innerHTML = '<span></span><span></span><span></span>';
      msgBox.appendChild(typing);
      msgBox.scrollTop = msgBox.scrollHeight;
      
      try {
        const chatResp = await fetch('/api/chat', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: text }) });
        const { reply } = await chatResp.json();
        typing.remove();
        addMsg(reply, 'sid');
        showSpeech(reply);
        
        await playVoice(reply);
      } catch {
        typing.remove();
        addMsg("Oops, brain freeze! ðŸ¦ž", 'sid');
        showSpeech("Oops, brain freeze! ðŸ¦ž");
        setTimeout(hideSpeech, 2000);
      }
      sendBtn.disabled = false;
      input.focus();
    }
    
    sendBtn.onclick = send;
    input.onkeypress = e => { if (e.key === 'Enter') send(); };
  </script>
</body>
</html>
