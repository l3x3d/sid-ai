<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SID - The Lobster ðŸ¦ž</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: linear-gradient(135deg, #0a0a0a 0%, #1a0a0a 50%, #0a0a0a 100%);
      font-family: 'Courier New', monospace;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    /* Lobster container - top half */
    #lobster-container {
      flex: 0 0 50vh;
      position: relative;
      overflow: hidden;
    }
    #canvas { display: block; width: 100%; height: 100%; }
    
    #speech-box {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.9);
      border: 2px solid #ff4444;
      border-radius: 10px;
      padding: 12px 20px;
      color: #fff;
      font-size: 16px;
      max-width: 500px;
      text-align: center;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 10;
    }
    #speech-box.visible { opacity: 1; }
    
    /* Chat container - bottom half */
    #chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #111;
      border-top: 2px solid #ff4444;
    }
    
    #chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .message {
      max-width: 80%;
      padding: 10px 15px;
      border-radius: 15px;
      font-size: 14px;
      line-height: 1.4;
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .message.user {
      background: #333;
      color: #fff;
      align-self: flex-end;
      border-bottom-right-radius: 5px;
    }
    
    .message.sid {
      background: linear-gradient(135deg, #cc2200, #ff4444);
      color: #fff;
      align-self: flex-start;
      border-bottom-left-radius: 5px;
    }
    
    .message.sid .name {
      font-weight: bold;
      margin-bottom: 4px;
      font-size: 12px;
      opacity: 0.8;
    }
    
    .message.typing {
      background: #222;
      color: #888;
    }
    
    .typing-dots {
      display: inline-flex;
      gap: 4px;
    }
    .typing-dots span {
      width: 6px;
      height: 6px;
      background: #888;
      border-radius: 50%;
      animation: bounce 1.4s ease-in-out infinite;
    }
    .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
    .typing-dots span:nth-child(3) { animation-delay: 0.4s; }
    
    @keyframes bounce {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-6px); }
    }
    
    #chat-input-container {
      display: flex;
      gap: 10px;
      padding: 15px;
      background: #0a0a0a;
      border-top: 1px solid #222;
    }
    
    #chat-input {
      flex: 1;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 25px;
      padding: 12px 20px;
      color: #fff;
      font-family: inherit;
      font-size: 14px;
      outline: none;
      transition: border-color 0.2s;
    }
    #chat-input:focus { border-color: #ff4444; }
    #chat-input::placeholder { color: #666; }
    
    #send-btn {
      background: #ff4444;
      border: none;
      color: white;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 20px;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #send-btn:hover { background: #ff6666; transform: scale(1.05); }
    #send-btn:disabled { background: #444; cursor: not-allowed; }
    
    /* Audio player for voice */
    .voice-msg {
      margin-top: 8px;
    }
    .voice-msg audio {
      height: 32px;
      width: 200px;
    }
    
    /* Welcome message */
    .welcome {
      text-align: center;
      color: #666;
      padding: 20px;
      font-size: 13px;
    }
    .welcome h2 { color: #ff4444; margin-bottom: 10px; }
  </style>
</head>
<body>
  <!-- Lobster Head -->
  <div id="lobster-container">
    <canvas id="canvas"></canvas>
    <div id="speech-box"></div>
  </div>
  
  <!-- Chat -->
  <div id="chat-container">
    <div id="chat-messages">
      <div class="welcome">
        <h2>ðŸ¦ž Chat with SID</h2>
        <p>Type a message below to talk to your favorite AI lobster</p>
      </div>
    </div>
    <div id="chat-input-container">
      <input type="text" id="chat-input" placeholder="Say something to SID..." autocomplete="off">
      <button id="send-btn">âž¤</button>
    </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
      }
    }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    
    // ============ CHAT STATE ============
    let isSpeaking = false;
    let speakingTime = 0;
    
    // ============ THREE.JS SETUP ============
    const canvas = document.getElementById('canvas');
    const container = document.getElementById('lobster-container');
    
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    
    function updateSize() {
      const w = container.clientWidth;
      const h = container.clientHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
    camera.position.set(0, 0, 4);
    
    updateSize();
    window.addEventListener('resize', updateSize);
    
    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const keyLight = new THREE.DirectionalLight(0xffffff, 1);
    keyLight.position.set(2, 3, 4);
    scene.add(keyLight);
    const fillLight = new THREE.DirectionalLight(0xff4444, 0.3);
    fillLight.position.set(-2, 0, 2);
    scene.add(fillLight);
    
    // ============ LOBSTER ============
    const lobsterGroup = new THREE.Group();
    lobsterGroup.position.y = 0.2;
    scene.add(lobsterGroup);
    
    const shellMat = new THREE.MeshStandardMaterial({ color: 0xcc2200, roughness: 0.4, metalness: 0.1 });
    const darkShellMat = new THREE.MeshStandardMaterial({ color: 0x881100, roughness: 0.5, metalness: 0.1 });
    const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1, metalness: 0.8 });
    const eyeWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffffcc, emissive: 0x444422, roughness: 0.3 });
    const antennaMat = new THREE.MeshStandardMaterial({ color: 0xdd4422 });
    
    // Head
    const headGeom = new THREE.SphereGeometry(1, 32, 32);
    headGeom.scale(1, 0.8, 1.1);
    lobsterGroup.add(new THREE.Mesh(headGeom, shellMat));
    
    // Ridge
    const ridge = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.3, 1.2), darkShellMat);
    ridge.position.set(0, 0.7, 0.1);
    lobsterGroup.add(ridge);
    
    // Spikes
    for (let i = 0; i < 5; i++) {
      const spike = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.15, 8), darkShellMat);
      spike.position.set(0, 0.85, -0.4 + i * 0.2);
      lobsterGroup.add(spike);
    }
    
    // Eye stalks
    const stalkGeom = new THREE.CylinderGeometry(0.08, 0.1, 0.4, 16);
    const leftStalk = new THREE.Mesh(stalkGeom, shellMat);
    leftStalk.position.set(-0.35, 0.5, 0.7);
    leftStalk.rotation.set(-0.5, 0, -0.3);
    lobsterGroup.add(leftStalk);
    const rightStalk = new THREE.Mesh(stalkGeom, shellMat);
    rightStalk.position.set(0.35, 0.5, 0.7);
    rightStalk.rotation.set(-0.5, 0, 0.3);
    lobsterGroup.add(rightStalk);
    
    // Eyes
    const eyeGeom = new THREE.SphereGeometry(0.12, 16, 16);
    const leftEye = new THREE.Mesh(eyeGeom, eyeWhiteMat);
    leftEye.position.set(-0.45, 0.7, 0.9);
    lobsterGroup.add(leftEye);
    const rightEye = new THREE.Mesh(eyeGeom, eyeWhiteMat);
    rightEye.position.set(0.45, 0.7, 0.9);
    lobsterGroup.add(rightEye);
    
    // Pupils
    const pupilGeom = new THREE.SphereGeometry(0.06, 16, 16);
    const leftPupil = new THREE.Mesh(pupilGeom, eyeMat);
    leftPupil.position.set(-0.45, 0.7, 1.02);
    lobsterGroup.add(leftPupil);
    const rightPupil = new THREE.Mesh(pupilGeom, eyeMat);
    rightPupil.position.set(0.45, 0.7, 1.02);
    lobsterGroup.add(rightPupil);
    
    // Antennae (simplified)
    function makeAntenna(xSign) {
      const g = new THREE.Group();
      for (let i = 0; i < 6; i++) {
        const seg = new THREE.Mesh(
          new THREE.CylinderGeometry(0.02, 0.025, 0.25, 8),
          antennaMat
        );
        seg.position.y = i * 0.22;
        seg.rotation.z = xSign * i * 0.15;
        seg.rotation.x = -i * 0.1;
        g.add(seg);
      }
      return g;
    }
    const leftAnt = makeAntenna(-1);
    leftAnt.position.set(-0.3, 0.7, 0.8);
    lobsterGroup.add(leftAnt);
    const rightAnt = makeAntenna(1);
    rightAnt.position.set(0.3, 0.7, 0.8);
    lobsterGroup.add(rightAnt);
    
    // Mandibles
    const mandGeom = new THREE.BoxGeometry(0.15, 0.08, 0.3);
    const leftMand = new THREE.Mesh(mandGeom, darkShellMat);
    leftMand.position.set(-0.2, -0.1, 0.9);
    lobsterGroup.add(leftMand);
    const rightMand = new THREE.Mesh(mandGeom, darkShellMat);
    rightMand.position.set(0.2, -0.1, 0.9);
    lobsterGroup.add(rightMand);
    
    // Jaw
    const jaw = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.1, 0.25), darkShellMat);
    jaw.position.set(0, -0.3, 0.85);
    lobsterGroup.add(jaw);
    
    // ============ ANIMATION ============
    const mouse = { x: 0, y: 0 };
    let blinkTimer = 0, isBlinking = false;
    
    document.addEventListener('mousemove', e => {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    });
    
    const clock = new THREE.Clock();
    
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const t = clock.getElapsedTime();
      
      // Subtle head movement
      lobsterGroup.rotation.y = Math.sin(t * 0.5) * 0.1;
      lobsterGroup.rotation.x = Math.sin(t * 0.3) * 0.05;
      
      // Eye tracking
      leftPupil.position.x = -0.45 + mouse.x * 0.05;
      leftPupil.position.y = 0.7 + mouse.y * 0.03;
      rightPupil.position.x = 0.45 + mouse.x * 0.05;
      rightPupil.position.y = 0.7 + mouse.y * 0.03;
      
      // Blinking
      blinkTimer += delta;
      if (!isBlinking && blinkTimer > 3 + Math.random() * 2) {
        isBlinking = true;
        blinkTimer = 0;
      }
      if (isBlinking) {
        const p = blinkTimer * 10;
        const s = p < 1 ? 1 - p : (p < 2 ? p - 1 : 1);
        leftEye.scale.y = rightEye.scale.y = s;
        leftPupil.scale.y = rightPupil.scale.y = s;
        if (p > 2) isBlinking = false;
      }
      
      // Antenna sway
      leftAnt.rotation.z = -0.2 + Math.sin(t * 1.5) * 0.1;
      rightAnt.rotation.z = 0.2 + Math.sin(t * 1.5 + 0.5) * 0.1;
      
      // Speaking animation
      if (isSpeaking) {
        speakingTime += delta;
        const open = Math.sin(speakingTime * 20) * 0.5 + 0.5;
        leftMand.rotation.z = -open * 0.3;
        rightMand.rotation.z = open * 0.3;
        jaw.position.y = -0.3 - open * 0.1;
      } else {
        leftMand.rotation.z *= 0.9;
        rightMand.rotation.z *= 0.9;
        jaw.position.y += (-0.3 - jaw.position.y) * 0.1;
      }
      
      renderer.render(scene, camera);
    }
    animate();
    
    // ============ CHAT FUNCTIONS ============
    const messagesEl = document.getElementById('chat-messages');
    const inputEl = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');
    const speechBox = document.getElementById('speech-box');
    
    function addMessage(text, type, voice = null) {
      // Remove welcome message
      const welcome = messagesEl.querySelector('.welcome');
      if (welcome) welcome.remove();
      
      const div = document.createElement('div');
      div.className = `message ${type}`;
      
      if (type === 'sid') {
        div.innerHTML = `<div class="name">ðŸ¦ž SID</div>${text}`;
      } else {
        div.textContent = text;
      }
      
      // Add voice player if present
      if (voice) {
        const voiceDiv = document.createElement('div');
        voiceDiv.className = 'voice-msg';
        voiceDiv.innerHTML = `<audio controls src="${voice}"></audio>`;
        div.appendChild(voiceDiv);
      }
      
      messagesEl.appendChild(div);
      messagesEl.scrollTop = messagesEl.scrollHeight;
      
      return div;
    }
    
    function showTyping() {
      const div = document.createElement('div');
      div.className = 'message sid typing';
      div.id = 'typing-indicator';
      div.innerHTML = `<div class="typing-dots"><span></span><span></span><span></span></div>`;
      messagesEl.appendChild(div);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }
    
    function hideTyping() {
      const el = document.getElementById('typing-indicator');
      if (el) el.remove();
    }
    
    function showSpeechBubble(text) {
      speechBox.textContent = text;
      speechBox.classList.add('visible');
      isSpeaking = true;
      speakingTime = 0;
      
      setTimeout(() => {
        speechBox.classList.remove('visible');
        isSpeaking = false;
      }, Math.min(text.length * 60 + 1000, 5000));
    }
    
    // Quick local responses (no API needed)
    function getLocalResponse(text) {
      const lower = text.toLowerCase();
      
      const patterns = [
        [/\b(gm|good morning)\b/, ["Gm gm! ðŸ¦ž", "Gm dude!", "Morning! How's it going?"]],
        [/\b(gn|good night)\b/, ["Gn bro, sleep well ðŸ¦ž", "Night dude!", "Sweet dreams!"]],
        [/\b(hello|hi|hey|sup|yo)\b/, ["Yo! What's good? ðŸ¦ž", "Hey hey!", "Sup dude!"]],
        [/how are you|how('s| is) it going/, ["Chillin as always! You?", "Living the dream ðŸ¦ž"]],
        [/thanks|thank you/, ["No prob! ðŸ¦ž", "Anytime dude!", "You got it!"]],
        [/who are you|what are you/, ["I'm Sid - a chill AI lobster just vibing ðŸ¦ž"]],
        [/love you/, ["Love you too! ðŸ¦žâ¤ï¸", "Right back at ya!"]],
        [/\?$/, ["Hmm good question dude", "Let me think... ðŸ¦ž", "Interesting thought!"]],
      ];
      
      for (const [pattern, responses] of patterns) {
        if (pattern.test(lower)) {
          return responses[Math.floor(Math.random() * responses.length)];
        }
      }
      
      const fallbacks = [
        "I hear you dude ðŸ¦ž",
        "That's cool!",
        "For sure bro",
        "Haha nice",
        "Vibes ðŸ¦ž",
      ];
      return fallbacks[Math.floor(Math.random() * fallbacks.length)];
    }
    
    async function sendMessage() {
      const text = inputEl.value.trim();
      if (!text) return;
      
      inputEl.value = '';
      sendBtn.disabled = true;
      
      addMessage(text, 'user');
      showTyping();
      
      // Simulate thinking delay
      await new Promise(r => setTimeout(r, 800 + Math.random() * 700));
      
      hideTyping();
      
      const response = getLocalResponse(text);
      showSpeechBubble(response);
      addMessage(response, 'sid');
      
      sendBtn.disabled = false;
      inputEl.focus();
    }
    
    sendBtn.addEventListener('click', sendMessage);
    inputEl.addEventListener('keypress', e => {
      if (e.key === 'Enter') sendMessage();
    });
    
    // Focus input on load
    inputEl.focus();
  </script>
</body>
</html>
