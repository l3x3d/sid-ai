<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SID - The Lobster ü¶û</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: linear-gradient(180deg, #0a0a12 0%, #1a0a0a 50%, #0a0808 100%);
      font-family: 'Courier New', monospace;
      height: 100vh;
      overflow: hidden;
    }
    
    #canvas { display: block; width: 100%; height: 100%; }
    
    #speech-box {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.9);
      border: 2px solid #ff4444;
      border-radius: 10px;
      padding: 12px 20px;
      color: #fff;
      font-size: 16px;
      max-width: 500px;
      text-align: center;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 10;
    }
    #speech-box.visible { opacity: 1; }
    
    /* Chat Terminal */
    #chat-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 60px;
      height: 60px;
      background: linear-gradient(135deg, #cc2200, #ff4444);
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 28px;
      color: white;
      box-shadow: 0 4px 20px rgba(255,68,68,0.4);
      transition: all 0.3s;
      z-index: 1000;
    }
    #chat-toggle:hover { transform: scale(1.1); }
    #chat-toggle.open { background: #333; }
    
    #chat-terminal {
      position: fixed;
      bottom: 100px;
      right: 20px;
      width: 380px;
      height: 450px;
      background: rgba(10, 10, 10, 0.95);
      border: 1px solid #ff4444;
      border-radius: 12px;
      display: none;
      flex-direction: column;
      z-index: 999;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }
    #chat-terminal.open { display: flex; }
    
    #chat-header {
      background: linear-gradient(135deg, #cc2200, #991100);
      padding: 12px 15px;
      display: flex;
      align-items: center;
      gap: 10px;
      border-radius: 12px 12px 0 0;
    }
    #chat-header .title { flex: 1; font-weight: bold; color: #fff; font-size: 14px; }
    #chat-header .status { font-size: 10px; color: #88ff88; }
    #chat-header .close-btn { background: none; border: none; color: #fff; font-size: 18px; cursor: pointer; opacity: 0.7; }
    #chat-header .close-btn:hover { opacity: 1; }
    
    #chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 13px;
    }
    #chat-messages::-webkit-scrollbar { width: 6px; }
    #chat-messages::-webkit-scrollbar-thumb { background: #ff4444; border-radius: 3px; }
    
    .msg { max-width: 85%; padding: 8px 12px; border-radius: 12px; line-height: 1.4; animation: fadeIn 0.2s ease; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; } }
    .msg.user { background: #2a2a2a; color: #fff; align-self: flex-end; border-bottom-right-radius: 4px; }
    .msg.sid { background: linear-gradient(135deg, #cc2200, #aa1100); color: #fff; align-self: flex-start; border-bottom-left-radius: 4px; }
    .msg.system { background: transparent; color: #666; font-size: 11px; text-align: center; align-self: center; }
    
    .typing { display: flex; gap: 4px; padding: 8px 12px; }
    .typing span { width: 6px; height: 6px; background: #ff6644; border-radius: 50%; animation: bounce 1.4s ease-in-out infinite; }
    .typing span:nth-child(2) { animation-delay: 0.2s; }
    .typing span:nth-child(3) { animation-delay: 0.4s; }
    @keyframes bounce { 0%, 60%, 100% { transform: translateY(0); } 30% { transform: translateY(-5px); } }
    
    #chat-input-area { display: flex; gap: 8px; padding: 12px; background: #0a0a0a; border-top: 1px solid #222; border-radius: 0 0 12px 12px; }
    #chat-input { flex: 1; background: #1a1a1a; border: 1px solid #333; border-radius: 20px; padding: 10px 15px; color: #fff; font-family: inherit; font-size: 13px; outline: none; }
    #chat-input:focus { border-color: #ff4444; }
    #chat-input::placeholder { color: #555; }
    #send-btn { background: #ff4444; border: none; color: white; width: 40px; height: 40px; border-radius: 50%; cursor: pointer; font-size: 16px; }
    #send-btn:hover { background: #ff6666; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="speech-box"></div>
  
  <button id="chat-toggle" onclick="toggleChat()">ü¶û</button>
  
  <div id="chat-terminal">
    <div id="chat-header">
      <span class="title">ü¶û SID Terminal</span>
      <span class="status">‚óè online</span>
      <button class="close-btn" onclick="toggleChat()">‚úï</button>
    </div>
    <div id="chat-messages">
      <div class="msg system">Chat with SID</div>
    </div>
    <div id="chat-input-area">
      <input type="text" id="chat-input" placeholder="Say something..." autocomplete="off">
      <button id="send-btn">‚û§</button>
    </div>
  </div>

  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    
    let chatOpen = false;
    let isSpeaking = false;
    let speakingTime = 0;
    
    window.toggleChat = function() {
      chatOpen = !chatOpen;
      document.getElementById('chat-terminal').classList.toggle('open', chatOpen);
      document.getElementById('chat-toggle').classList.toggle('open', chatOpen);
      document.getElementById('chat-toggle').textContent = chatOpen ? '‚úï' : 'ü¶û';
      if (chatOpen) document.getElementById('chat-input').focus();
    };
    
    // ============ RENDERER ============
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0.3, 5.5);
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // ============ LIGHTING ============
    const ambient = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambient);
    
    const keyLight = new THREE.DirectionalLight(0xfff5ee, 1.2);
    keyLight.position.set(3, 4, 5);
    keyLight.castShadow = true;
    scene.add(keyLight);
    
    const fillLight = new THREE.DirectionalLight(0xff6644, 0.4);
    fillLight.position.set(-3, 0, 3);
    scene.add(fillLight);
    
    const rimLight = new THREE.DirectionalLight(0xff8866, 0.6);
    rimLight.position.set(0, -2, -4);
    scene.add(rimLight);
    
    const underLight = new THREE.PointLight(0x4488ff, 0.3, 10);
    underLight.position.set(0, -3, 2);
    scene.add(underLight);
    
    // ============ MATERIALS ============
    const shellMat = new THREE.MeshStandardMaterial({ 
      color: 0xbb2211,
      roughness: 0.35,
      metalness: 0.1,
    });
    
    const darkShellMat = new THREE.MeshStandardMaterial({ 
      color: 0x771108,
      roughness: 0.4,
      metalness: 0.05,
    });
    
    const lightShellMat = new THREE.MeshStandardMaterial({ 
      color: 0xdd4422,
      roughness: 0.3,
      metalness: 0.15,
    });
    
    const eyeWhiteMat = new THREE.MeshStandardMaterial({ 
      color: 0x111111,
      roughness: 0.1,
      metalness: 0.9,
    });
    
    const pupilMat = new THREE.MeshStandardMaterial({ 
      color: 0x00ff88,
      emissive: 0x00ff44,
      emissiveIntensity: 0.8,
      roughness: 0.2,
    });
    
    const antennaMat = new THREE.MeshStandardMaterial({ 
      color: 0xcc3311,
      roughness: 0.5,
    });
    
    // ============ LOBSTER GROUP ============
    const lobster = new THREE.Group();
    scene.add(lobster);
    
    // --- CARAPACE (main head/body shell) ---
    const carapaceGeom = new THREE.SphereGeometry(1, 48, 48);
    carapaceGeom.scale(1.1, 0.85, 1.3);
    const carapace = new THREE.Mesh(carapaceGeom, shellMat);
    carapace.castShadow = true;
    lobster.add(carapace);
    
    // Carapace texture bumps
    for (let i = 0; i < 40; i++) {
      const bumpGeom = new THREE.SphereGeometry(0.04 + Math.random() * 0.04, 8, 8);
      const bump = new THREE.Mesh(bumpGeom, shellMat);
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI * 0.6 + 0.2;
      bump.position.setFromSphericalCoords(0.95, phi, theta);
      bump.position.z *= 1.2;
      lobster.add(bump);
    }
    
    // --- ROSTRUM (pointy nose/beak) ---
    const rostrumGeom = new THREE.ConeGeometry(0.15, 0.8, 8);
    const rostrum = new THREE.Mesh(rostrumGeom, darkShellMat);
    rostrum.position.set(0, 0.35, 1.15);
    rostrum.rotation.x = -Math.PI / 2 + 0.3;
    lobster.add(rostrum);
    
    // Rostrum spikes
    for (let i = 0; i < 4; i++) {
      const spike = new THREE.Mesh(new THREE.ConeGeometry(0.03, 0.12, 6), darkShellMat);
      spike.position.set((i - 1.5) * 0.08, 0.45, 1.0 + i * 0.08);
      spike.rotation.x = -0.3;
      lobster.add(spike);
    }
    
    // --- CENTRAL RIDGE ---
    const ridgeGeom = new THREE.BoxGeometry(0.12, 0.25, 1.4);
    const ridge = new THREE.Mesh(ridgeGeom, darkShellMat);
    ridge.position.set(0, 0.75, -0.1);
    lobster.add(ridge);
    
    // Ridge spines
    for (let i = 0; i < 7; i++) {
      const spine = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.18, 6), darkShellMat);
      spine.position.set(0, 0.9, -0.5 + i * 0.18);
      lobster.add(spine);
    }
    
    // --- EYE STALKS ---
    const stalkGeom = new THREE.CylinderGeometry(0.06, 0.09, 0.5, 12);
    
    const lStalk = new THREE.Mesh(stalkGeom, shellMat);
    lStalk.position.set(-0.4, 0.4, 0.85);
    lStalk.rotation.set(-0.6, 0, -0.4);
    lobster.add(lStalk);
    
    const rStalk = new THREE.Mesh(stalkGeom, shellMat);
    rStalk.position.set(0.4, 0.4, 0.85);
    rStalk.rotation.set(-0.6, 0, 0.4);
    lobster.add(rStalk);
    
    // --- EYES ---
    const eyeGeom = new THREE.SphereGeometry(0.14, 24, 24);
    
    const lEye = new THREE.Mesh(eyeGeom, eyeWhiteMat);
    lEye.position.set(-0.52, 0.62, 1.05);
    lobster.add(lEye);
    
    const rEye = new THREE.Mesh(eyeGeom, eyeWhiteMat);
    rEye.position.set(0.52, 0.62, 1.05);
    lobster.add(rEye);
    
    // Pupils (glowing)
    const pupilGeom = new THREE.SphereGeometry(0.07, 16, 16);
    
    const lPupil = new THREE.Mesh(pupilGeom, pupilMat);
    lPupil.position.set(-0.52, 0.62, 1.18);
    lobster.add(lPupil);
    
    const rPupil = new THREE.Mesh(pupilGeom, pupilMat);
    rPupil.position.set(0.52, 0.62, 1.18);
    lobster.add(rPupil);
    
    // --- ANTENNAE (long sensory) ---
    function makeAntenna(xSign) {
      const group = new THREE.Group();
      const segments = 12;
      for (let i = 0; i < segments; i++) {
        const thickness = 0.025 - i * 0.0015;
        const len = 0.35 - i * 0.015;
        const seg = new THREE.Mesh(
          new THREE.CylinderGeometry(thickness * 0.8, thickness, len, 8),
          antennaMat
        );
        seg.position.y = i * 0.3;
        seg.rotation.z = xSign * i * 0.12;
        seg.rotation.x = -i * 0.06;
        group.add(seg);
      }
      return group;
    }
    
    const lAnt = makeAntenna(-1);
    lAnt.position.set(-0.25, 0.6, 1.0);
    lAnt.rotation.x = -0.4;
    lobster.add(lAnt);
    
    const rAnt = makeAntenna(1);
    rAnt.position.set(0.25, 0.6, 1.0);
    rAnt.rotation.x = -0.4;
    lobster.add(rAnt);
    
    // --- ANTENNULES (short feelers) ---
    function makeAntennule(xSign) {
      const group = new THREE.Group();
      for (let i = 0; i < 6; i++) {
        const seg = new THREE.Mesh(
          new THREE.CylinderGeometry(0.015, 0.02, 0.15, 6),
          antennaMat
        );
        seg.position.y = i * 0.12;
        seg.rotation.z = xSign * i * 0.1;
        group.add(seg);
      }
      return group;
    }
    
    const lAntennule = makeAntennule(-0.5);
    lAntennule.position.set(-0.15, 0.3, 1.2);
    lAntennule.rotation.x = -0.6;
    lobster.add(lAntennule);
    
    const rAntennule = makeAntennule(0.5);
    rAntennule.position.set(0.15, 0.3, 1.2);
    rAntennule.rotation.x = -0.6;
    lobster.add(rAntennule);
    
    // --- MANDIBLES / MOUTH PARTS ---
    const mandibleGeom = new THREE.BoxGeometry(0.12, 0.06, 0.25);
    
    const lMand = new THREE.Mesh(mandibleGeom, darkShellMat);
    lMand.position.set(-0.18, 0.0, 1.0);
    lobster.add(lMand);
    
    const rMand = new THREE.Mesh(mandibleGeom, darkShellMat);
    rMand.position.set(0.18, 0.0, 1.0);
    lobster.add(rMand);
    
    // Maxillipeds (mouth feelers)
    for (let i = 0; i < 3; i++) {
      const lMax = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.025, 0.2, 6), lightShellMat);
      lMax.position.set(-0.1 - i * 0.06, -0.1, 1.05);
      lMax.rotation.set(-0.8, 0, -0.2 - i * 0.15);
      lobster.add(lMax);
      
      const rMax = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.025, 0.2, 6), lightShellMat);
      rMax.position.set(0.1 + i * 0.06, -0.1, 1.05);
      rMax.rotation.set(-0.8, 0, 0.2 + i * 0.15);
      lobster.add(rMax);
    }
    
    // --- CLAWS (front) ---
    function makeClaw(xSign) {
      const group = new THREE.Group();
      
      // Arm segments
      const arm1 = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.5, 8), shellMat);
      arm1.rotation.z = xSign * 0.8;
      arm1.rotation.x = -0.3;
      group.add(arm1);
      
      const arm2 = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.08, 0.4, 8), shellMat);
      arm2.position.set(xSign * 0.35, -0.15, 0.1);
      arm2.rotation.z = xSign * 0.4;
      group.add(arm2);
      
      // Claw pincer
      const clawBase = new THREE.Mesh(new THREE.SphereGeometry(0.12, 12, 12), lightShellMat);
      clawBase.scale.set(1.3, 0.8, 1.5);
      clawBase.position.set(xSign * 0.55, -0.25, 0.2);
      group.add(clawBase);
      
      // Upper pincer
      const upperPincer = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.04, 0.25), lightShellMat);
      upperPincer.position.set(xSign * 0.6, -0.18, 0.35);
      group.add(upperPincer);
      
      // Lower pincer (moves when speaking)
      const lowerPincer = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.04, 0.25), lightShellMat);
      lowerPincer.position.set(xSign * 0.6, -0.28, 0.35);
      group.add(lowerPincer);
      
      return group;
    }
    
    const lClaw = makeClaw(-1);
    lClaw.position.set(-0.5, -0.3, 0.5);
    lobster.add(lClaw);
    
    const rClaw = makeClaw(1);
    rClaw.position.set(0.5, -0.3, 0.5);
    lobster.add(rClaw);
    
    // --- WALKING LEGS (visible at bottom) ---
    for (let side = -1; side <= 1; side += 2) {
      for (let i = 0; i < 3; i++) {
        const leg = new THREE.Group();
        
        const seg1 = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.04, 0.3, 6), shellMat);
        seg1.rotation.z = side * (0.6 + i * 0.15);
        leg.add(seg1);
        
        const seg2 = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.03, 0.25, 6), shellMat);
        seg2.position.set(side * 0.2, -0.15, 0);
        seg2.rotation.z = side * 0.3;
        leg.add(seg2);
        
        leg.position.set(side * 0.7, -0.5 - i * 0.15, 0.2 - i * 0.3);
        lobster.add(leg);
      }
    }
    
    // ============ ANIMATION ============
    const mouse = { x: 0, y: 0 };
    let blinkTimer = 0, isBlinking = false;
    
    document.addEventListener('mousemove', e => {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    });
    
    const clock = new THREE.Clock();
    
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const t = clock.getElapsedTime();
      
      // Subtle idle movement
      lobster.rotation.y = Math.sin(t * 0.4) * 0.12;
      lobster.rotation.x = Math.sin(t * 0.25) * 0.04;
      lobster.position.y = Math.sin(t * 0.5) * 0.02;
      
      // Eye tracking
      const eyeX = mouse.x * 0.04;
      const eyeY = mouse.y * 0.025;
      lPupil.position.x = -0.52 + eyeX;
      lPupil.position.y = 0.62 + eyeY;
      rPupil.position.x = 0.52 + eyeX;
      rPupil.position.y = 0.62 + eyeY;
      
      // Pupil glow pulse
      pupilMat.emissiveIntensity = 0.6 + Math.sin(t * 2) * 0.3;
      
      // Blinking
      blinkTimer += delta;
      if (!isBlinking && blinkTimer > 2.5 + Math.random() * 2.5) { 
        isBlinking = true; 
        blinkTimer = 0; 
      }
      if (isBlinking) {
        const p = blinkTimer * 12;
        const s = p < 1 ? 1 - p : (p < 2 ? p - 1 : 1);
        lEye.scale.y = rEye.scale.y = s;
        lPupil.scale.y = rPupil.scale.y = s;
        if (p > 2) isBlinking = false;
      }
      
      // Antenna sway
      lAnt.rotation.z = -0.15 + Math.sin(t * 1.2) * 0.08;
      lAnt.rotation.x = -0.4 + Math.sin(t * 0.9) * 0.05;
      rAnt.rotation.z = 0.15 + Math.sin(t * 1.2 + 0.5) * 0.08;
      rAnt.rotation.x = -0.4 + Math.sin(t * 0.9 + 0.5) * 0.05;
      
      // Antennules twitch
      lAntennule.rotation.z = Math.sin(t * 3) * 0.1;
      rAntennule.rotation.z = Math.sin(t * 3 + 1) * 0.1;
      
      // Speaking animation
      if (isSpeaking) {
        speakingTime += delta;
        const open = Math.sin(speakingTime * 18) * 0.5 + 0.5;
        lMand.rotation.z = -open * 0.25;
        rMand.rotation.z = open * 0.25;
        lMand.position.y = open * 0.03;
        rMand.position.y = open * 0.03;
        
        // Claws move slightly when talking
        lClaw.rotation.z = Math.sin(speakingTime * 8) * 0.05;
        rClaw.rotation.z = Math.sin(speakingTime * 8 + 0.5) * 0.05;
      } else {
        lMand.rotation.z *= 0.9;
        rMand.rotation.z *= 0.9;
        lMand.position.y *= 0.9;
        rMand.position.y *= 0.9;
        lClaw.rotation.z *= 0.95;
        rClaw.rotation.z *= 0.95;
      }
      
      renderer.render(scene, camera);
    }
    animate();
    
    // ============ CHAT ============
    const msgBox = document.getElementById('chat-messages');
    const input = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');
    const speechBox = document.getElementById('speech-box');
    
    function addMsg(text, type) {
      const div = document.createElement('div');
      div.className = `msg ${type}`;
      div.textContent = text;
      msgBox.appendChild(div);
      msgBox.scrollTop = msgBox.scrollHeight;
    }
    
    function showSpeech(text) {
      speechBox.textContent = text;
      speechBox.classList.add('visible');
      isSpeaking = true;
      speakingTime = 0;
      setTimeout(() => { speechBox.classList.remove('visible'); isSpeaking = false; }, Math.min(text.length * 50 + 800, 4000));
    }
    
    function getResponse(text) {
      const l = text.toLowerCase();
      const p = [
        [/\b(gm|good morning)\b/, ["Gm gm! ü¶û", "Gm dude!"]],
        [/\b(gn|good night)\b/, ["Gn bro! ü¶û", "Sleep well!"]],
        [/\b(hello|hi|hey|sup|yo)\b/, ["Yo! ü¶û", "Hey!", "Sup dude!"]],
        [/how are you/, ["Chillin! You? ü¶û"]],
        [/thanks|thank you/, ["No prob! ü¶û"]],
        [/who are you/, ["I'm Sid - a chill AI lobster ü¶û"]],
        [/love you/, ["Love you too! ü¶û‚ù§Ô∏è"]],
      ];
      for (const [r, a] of p) if (r.test(l)) return a[Math.floor(Math.random() * a.length)];
      return ["Vibes ü¶û", "I hear you", "For sure", "Nice one"][Math.floor(Math.random() * 4)];
    }
    
    async function send() {
      const text = input.value.trim();
      if (!text) return;
      input.value = '';
      sendBtn.disabled = true;
      
      addMsg(text, 'user');
      
      const typing = document.createElement('div');
      typing.className = 'msg sid typing';
      typing.innerHTML = '<span></span><span></span><span></span>';
      msgBox.appendChild(typing);
      msgBox.scrollTop = msgBox.scrollHeight;
      
      await new Promise(r => setTimeout(r, 500 + Math.random() * 400));
      
      typing.remove();
      const resp = getResponse(text);
      addMsg(resp, 'sid');
      showSpeech(resp);
      
      sendBtn.disabled = false;
      input.focus();
    }
    
    sendBtn.onclick = send;
    input.onkeypress = e => { if (e.key === 'Enter') send(); };
  </script>
</body>
</html>
